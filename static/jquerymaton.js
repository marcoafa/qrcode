/ *! v1.9.1 jQuery | (C) 2005, 2012 jQuery Foundation, Inc. | jquery.org/license
// @ SourceMappingURL = jquery.min.map
* / (Function (e, t) {var n, r, i = typeof t, o = e.document, a = e.location, s = e.jQuery, u = e. $, L = {}, c = [], p = "1.9.1", f = c.concat, d = c.push, h = c.slice, g = c.indexOf, m = l.toString, y = l.hasOwnProperty, v = p.trim, b = function (e, t) {return new b.fn.init (e, t, r)}, x = / [+ -]? (?:. \ d * \ |) \ d + ( ?:?. [eE] [+ -] \ d + |) / fuente, w = / \ s + / g, T = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g, N = / ^ (?: (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, C = / ^ <(\ w +) \ ? s * \ /> (:? <\ / \ 1> |) $ /, k = / ^ [\],: {} \ s] * $ /, E = / (: ^ |: |,) (?: \ s * \ [) + / g, S = / \\ (?: [ "\\\ / bfnrt] | T [\ da-FA-F] {4}) / g, A = /" [^ "\\\ r \ n] *" | verdadero | falso | nula | -: | \ d +? (\ d + \?.) (?:? [eE] [+ -] \ d + |) / g, j = / ^ - MS - /, D = / - ([\ da-z]) / gi, L = function (e, t) {return t.toUpperCase ()}, H = function (e) {(O .addEventListener || "carga" === e.type || "completa" === o.readyState) && (q (), b.ready ())}, q = function () {o.addEventListener? ( o.removeEventListener ( "DOMContentLoaded", H,! 1), e.removeEventListener ( "carga", H,! 1)) :( o.detachEvent ( "onreadystatechange", H), e.detachEvent ( "onload", H ))}; b.fn = b.prototype = {jQuery: p, constructor: b, init: función (e, n, r) {var i, a; si (e) devolverá esto, si ( "cadena" == typeof e) {if (i = "<" === e.charAt (0) && ">" === e.charAt (e.length-1) && e.length> = 3? [nulo, e , null]:! N.exec (e) ,! i || i [1] && n) devuélvalo n || n.jquery (n || r) .find (e):? this.constructor (n). encontrar (e), si (i [1]) {if (n = n instanceof b n [0]: n, b.merge (esto, b.parseHTML (i [1], n && n.nodeType n.ownerDocument?? || n:? O, 0)), C.test (i [1]) && b.isPlainObject (n)) para (i n) b.isFunction (esto [i]) esta [i] (n [ i]): this.attr (i, n [i]); Retorno este} if (a = o.getElementById (i [2]), una a.parentNode &&) {if (i == a.id [2]! ) r.find retorno (e); this.length = 1, esta [0] = a} regreso this.context = O, = e this.selector, esto} regreso e.nodeType (this.context = esta [0? ] = e, this.length = 1, este):? b.isFunction (e) r.ready (e) :( e.selector == t && (this.selector = e.selector, this.context = e!. contexto), b.makeArray (e, este))}, el selector: "", longitud: 0, tamaño: function () {return} this.length, toArray: function () {h.call regreso (este)}, obtener: function (e) {return nula e == this.toArray ():?? 0> e esta [this.length + e]: esta [e]}, pushStack: function (e) {var t = b. fusionar (this.constructor (), e); return = t.prevObject esto, t.context = this.context, t}, cada uno: function (e, t) {b.each retorno (esto, e, t)} , listo: function (e) {b.ready.promise retorno () hecho (e), esto.}, rebanada: function () {return this.pushStack (h.apply (este, argumentos))}, en primer lugar: la función () {return this.eq (0)}, última: function () {return this.eq (-1)}, eq: function (e) {var t = this.length, n = + e + (0> e ? t: 0); return this.pushStack (n> = 0 && t> n [esta [n]]: [])}, mapa: function (e) {return this.pushStack (b.map (esto, la función (? t, n) {return e.call (t, n, t)}))}, final: function () {return this.prevObject || this.constructor (nulo)}, empuje: D, para ordenar: []. Ordena, empalme:. []} de empalme, b.fn.init.prototype = b.fn, b.extend = b.fn.extend = function () {var e, n, r, i, o, a, s = argumentos [0] || {}, u = 1, L = arguments.length, c = 1;! a ( "booleano" == typeof s && (c = s, s = argumentos [1] || {}, u = 2), "objeto" == typeof s || b.isFunction (s) || (s = {}), l === u && (s = este, - u); l> u, u ++) if (NULL! = (o = argumentos [u])) para (i en o) e = s [i], r = O [i], s! == r && (c && r && (b.isPlainObject (r) || (n = b.isArray (r))) (n (n = 1, a = e && b.isArray (e) e:?!? []):?? a = e && b.isPlainObject (e) e: {}, s [i] = b.extend (c, a, r)): r == t && (s [i] = r));} s de retorno, b.extend ({noConflict: función (t) {return correo . $ === b && (e $ = u.), t && e.jQuery === b && (e.jQuery = s), b}, isReady: 1, readyWait: 1, holdReady: function (e) {e? b.readyWait ++: b.ready}, listo: function (e) {if (e === 0 - b.readyWait:!?! b.isReady) (0) {if (! o.body) de retorno !! setTimeout (b.ready); b.isReady = 0, e == 0 && - b.readyWait> 0 || (n.resolveWith (O, [b]), b.fn.trigger && b (o)!. gatillo ( "listo") fuera ( "listo"))}}, isFunction:. función (e) {return "función" === b.type (e)}, isArray: Array.isArray || función (e) {return "matriz" === b.type (e)}, IsWindow: function (e) {return null = && correo electrónico == e.window!}, isNumeric: función (e) {return isNaN (parseFloat (e) ) && isFinite (e)}, tipo: function (e) {return nula == e e + "?": "? objeto" == typeof e || "función" == typeof e l [m.call (e)] || "objeto": typeof e}, isPlainObject: function (e) {if (|| e "objeto" == b.type (e) || || e.nodeType b.isWindow (e)!!) de retorno ! 1; try {si (e.constructor && y.call (e, "constructor") && y.call (e.constructor.prototype, "isPrototypeOf")!!) volver 1!} catch (n) {return 1! } var r; for (r en e); r retorno === t || y.call (e, r)}, isEmptyObject: function (e) {var t; para (t en e) return 1; regreso! 0}, el error: function (e) {error de banda (e)}, ParseHTML: (! e || "cadena" = typeof e) función (e, t, n) {if return null; "booleano" = = typeof t && (n = t, t = 1!), t = t || o; var r = C.exec (e), i = n && [];!? retorno r [t.createElement (r [1] )] :( r = b.buildFragment ([e], t, i), i && b (i) .Remove (), b.merge ([], r.childNodes))}, parseJSON: function (n) {return ? e.JSON && e.JSON.parse e.JSON.parse (n): === nula n n:? "cadena" == typeof n && (n = b.trim (n), n && k.test (n.replace ( .. S, "@") reemplazará (A, "]") en lugar de (E, ""))) Función (? "retorno" + n) () :( b.error ( "JSON no válido:" + n) , t)}, parseXML: function (n) {var r, i; si (n || "cadena" = typeof n) return null; try {e.DOMParser (i = new DOMParser, r = i!!?. parseFromString (n, "text / xml")) :( r = new ActiveXObject ( "Microsoft.XMLDOM"), r.async = "true", r.loadXML (n))} catch (o) {r} = t !. r && && r.documentElement volver r.getElementsByTagName ( "parsererror") de longitud || b.error ( "XML no válido:" + n), r}, NOOP: function () {}, globalEval: function (t) {t && b. trim (t) && (e.execScript || función (t) {e.eval.call (e, t)}) (t)}, camelCase: function (e) {e.replace retorno (j, "ms- ") .Colocar (D, L)}, nombreNodo: function (e, t) {return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()}, cada uno: function (e, t, n) {var r, i = 0, o = e.length, a = M (e), si (n) {if (a) {for (; o> i; i ++) si (r = t.apply (e [ i], n), r ===! 1) salto} else for (i en e) si (r = t.apply (e [i], n), r ===! 1) salto} else if ( a) {for (; o> i; i ++) si (r = t.call (e [i], i, e [i]), r === 1) descanso!} else for (i en e) si (! r = t.call (e [i], i, e [i]), r === 1) break;} e volver, recorte:? v && v.call ( "\ ufeff \ u00a0") función (e) {return nula e == "?": v.call (e)}: function (e) {return nula e ==? "" :( e + "") ") reemplazará (T,."}, MakeArray: function (e, t) {var n = t || []; devolver null && = e (M (Object (e)) b.merge (n, "cadena" == typeof e [e]?!?: e): d.call (n, e)), n}, InArray: function (e, t, n) {var r: si (t) {if (g) de retorno g.call (t, e, n) ; para (r = t.length, n = 0 n> n Math.max (0, r + n):?? n: 0; r> n; n ++) si (n de t && t [n] === correo ) de retorno n} return-1}, fusionar: function (e, n) {var r = n.length, i = e.length, o = 0; si ( "número" == typeof r) para (; r> ! O; O ++) e [i ++] = n [o]; cosa mientras (n [o] == t) e [i ++] = n [o ++]; retorno e.length = i, e}, grep: function ( , o ++) = r !! t (e [o]; e, t, n) {var r, i = [], o = 0, a = e.length; for (n = n !!; a> O ! O), n == r && i.push (e [o]);} i volver, mapa: function (e, t, n) {var r, i = 0, o = e.length, a = M (e ), s = []; si (a) para (; o> i; i ++) r = t (e [i], i, n), null = r && (s [s.length] = r);! else para (i en e) r = t (e [i], i, n), null && = r (s [s.length] = r); return f.apply ([], s)}, GUID: 1 , delegación: function (e, n) {var r, i, o, de regreso "cadena" == typeof n && (o = e [n], n = e, e = O), b.isFunction (e) (? r = h.call (argumentos, 2), i = function () {return e.apply (n || esto, r.concat (h.call (argumentos)))}, i.guid = = e e.guid .guid || b.guid ++, i): t}, acceso: function (e, n, r, i, o, a, s) {var u = 0, l = e.length, c = null == r y si ( "objeto" === b.type (r)) {o = 0;! a (u en r) b.access (e, n, u, r [u] ,! 0, a, s) } else if (i! == t && (o = 0, b.isFunction (i) || (s = 0), c && (s? (n.call (e, i), n = null) :( c = n, n = función (e, t, n) {return c.call (b (e), n)})), n)) para (; l> u; u ++) n (e [u], r, s i: i.call (e [u], u, n (e [u], r))); return o e:???? c n.call (e): l n (e [0 ], r): a}, ahora: function () {return (nueva fecha) .getTime ()}}), b.ready.promise = function (t) {if (n) si (n = b.Deferred (), "completar" === o.readyState) setTimeout (b.ready);! else if (o.addEventListener) o.addEventListener ( "DOMContentLoaded", H, 1), e.addEventListener ( "carga", H !, 1); else {o.attachEvent ( "onreadystatechange", H), e.attachEvent ( "onload", H); var r = 1;! try {r = null && == e.frameElement o.documentElement} catch ( i) {} r && && r.doScroll función a () {if (! b.isReady) {try {r.doScroll ( "izquierda")} catch (e) {return setTimeout (a, 50)} q (), b.ready ()}} ()} return n.promise (t)}, b.each ( "Número de Boole cadena de error función de matriz Fecha RegExp objeto" .split ( ""), la función (e, t) {l [ "[object "+ t +"] "] = t.toLowerCase ()}); función M (e) {var t = e.length, n = b.type (e); volver b.isWindow (e) ?! 1: 1 === e.nodeType && t 0:?! === n || "función" == n && (0 === t || "número" == typeof t && t> 0 && t-1 en e)} r "matriz" = b (O); var _ = {}; función F (e) {var t = _ [e] = {}; b.each retorno (e.match (w) || [], la función (e, n ) {t [n] = 0}), t} b.Callbacks = function (e) {e = "cadena" == typeof e _ [e] || F (e):? b.extend ({} , e);! var n, r, i, o, a, s, u = [], l = e.once && [], c = function (t) {for (r = e.memory && t, i = 0 , a = s || 0, s = 0, o = u.length, n = 0;! u && o> a; a ++) si (u [a] .apply (t [0], t [1]) == ! = 1 && e.stopOnFalse) {r = 1; descanso!} n = 1, u && (l l.length && c (l.shift ()?):!? r u = []: p.disable ())}, p = {add: function () {if (u) {var t = u.length; (función i (t) {b.each (t, la función (t, n) {var r = b.type (n); "función" === r && e.unique p.has (n) || u.push (n):?!? n && && n.length "cadena" == r && i (n)})}) (argumentos), n o = u.length: r && (s = t, c (r))}} devolver este, quite: function () {return u && b.each (argumentos, la función (e, t) {var r; while ((r = b. InArray (t, u, r))> - 1) u.splice (r, 1), n ​​&& (o> = r && o -, a> = r && a -)}), esta}, tiene: function (e) {? b.inArray declaración electrónica (e, u)> - 1: (! u || u.length)}, vacío: function () {return u = [], esto}, deshabilite: function () { volver u = l = r = t, esto}, discapacitados: function () {return u}, cerradura: function () {l = t, r || p.disable (), esto}, bloqueado retorno: function ( ) {return l!}, fireWith: function (e, t) {return t = t || [], t = [e, t.slice t.slice ():? t]! ,! u || i && l || (n l.push (t):? c (t)), esto}, fuego: function () {p.fireWith retorno (esta, argumentos), esto}, disparó: function () {return !! i }}; retorno p}, b.extend ({Diferido: function (e) {var t = [[ "determinación", "hecho", b.Callbacks ( "una vez que la memoria"), "resolvieron"], [ "rechazan "," fracaso ", b.Callbacks (" una vez que la memoria ")," rechazaron "], [" notificar "," progreso ", b.Callbacks (" memoria ")]], n =" pendiente ", r = { estado: function () {return n}, siempre: function () {i.done (argumentos) .fail (argumentos) de regreso, esto}, a continuación: function () {var e = argumentos; volver b.Deferred (function ( n) {b.each (t, la función (t, o) {var a = o [0], s = b.isFunction (e [t]) && e [t]; i [o [] 1] (función ( ) {var e = s && s.apply (esto, argumentos); e && b.isFunction (e.promise) e.promise () hecho (n.resolve) .fail (n.reject) .progress (n.notify)?.: n [a + "Con"] (este n.promise === r ():? esto, s [e]:? argumentos).})}), e = null}) promesa ()}, promesa: function ( e) {return null = e b.extend (e, r): r!?}}, i = {}; volver r.pipe = r.then, b.each (t, la función (e, o) {var a = O [2], s = o [3]; r [o [1]] = a.add, s && a.add (function () {n} = s, t [1 ^ e] [2] .disable , t [2] [2] .lock), i [o [0]] = function () {return i [o [0] + "Con"] (esta === i R:? esto, argumentos), esto}, i [o [0] + "Con"] = a.fireWith}), r.promise (i), e && e.call (i, i), i}, cuando: function (e) {var t = 0, n = h.call (argumentos), r = n.length, i = 1 == r || e && b.isFunction (e.promise) r:!? 0, o = 1 === i e:? b .Deferred (), una función = (e, t, n) {función de retorno (r) {t [e] = este, n [e] = arguments.length> 1 h.call (argumentos):? r, n ===? s o.notifyWith (t, n): - i || o.resolveWith (t, n)}}, s, u, l; si (r> 1) para la (s = array (r) , u = array (r), l = array (r); r> t;?. t ++) n [t] && b.isFunction (n [t] .promise) n [t] .promise () hecho (a ( t, l, n)) fAIL (o.reject) .progress (a (t, u, s)): -. i; i || volver o.resolveWith (l, n), o.promise ()} }), b.support = function () {var t, n, r, a, s, u, L, C, P, F, d = o.createElement ( "div"), si (d.setAttribute ( " className "," t "), d.innerHTML =" <link /> <table> </ table> <a href='/a'> un </a> <input type = "checkbox" /> ", n !! = d.getElementsByTagName ( "*"), r = d.getElementsByTagName ( "a") [0] ,! n || R || n.length) de retorno {}; s = o.createElement ( "seleccionar" ), l = s.appendChild (o.createElement ( "opción")), a = d.getElementsByTagName ( "entrada") [0], r.style.cssText = "top: 1px; float: left; opacidad :. 5 ", t = {getSetAttribute:" t "! == d.className, leadingWhitespace: 3 === d.firstChild.nodeType, tbody: d.getElementsByTagName (" tbody ") de longitud, htmlSerialize:. !! d. . getElementsByTagName ( "link") de longitud, el estilo: /top/.test (r.getAttribute ( "estilo")), hrefNormalized: "/ a" === r.getAttribute ( "href"), la opacidad: / ^ 0.5 /.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:!!a.value,optSelected:l.selected,enctype:!!o.createElement("form").enctype, html5Clone: ​​"<: nav> </: nav>" == o.createElement ( "VL") cloneNode .outerHTML, boxModel. (0): "CSS1Compat" === o.compatMode, deleteExpando: 0, noCloneEvent: 0, inlineBlockNeedsLayout: 1, shrinkWrapBlocks: 1, reliableMarginRight: 0, boxSizingReliable: 0, pixelPosition: 1}, a.checked = 0, t.noCloneChecked = a.cloneNode! (0). comprobado, s.disabled = 0, t.optDisabled = l.disabled;! try {eliminar d.test} catch (h) {t.deleteExpando = 1!} a = o.createElement ( "entrada"), a. setAttribute ( "valor", ""), t.input = "" === a.getAttribute ( "valor"), a.value = "t", a.setAttribute ( "tipo", "radio"), t .radioValue = "t" === a.value, a.setAttribute ( "marcada", "t"), a.setAttribute ( "nombre", "t"), u = o.createDocumentFragment (), u.appendChild (a), t.appendChecked = a.checked, t.checkClone = u.cloneNode (0) .cloneNode (0) .lastChild.checked, d.attachEvent && (d.attachEvent ( "onclick", function () { !! t.noCloneEvent = 1}), d.cloneNode (0) .click ()); for (f {a presentar:!!! 0, cambie: 0, focusin: 0}) d.setAttribute (c = " en "+ f," t "), t [f +" burbujas "] = c en e || d.attributes [c] .expando === 1;! d.style.backgroundClip = devolver" el contenido de la caja ", d.cloneNode (0) .style.backgroundClip = "", t.clearCloneStyle = "Content-box" === d.style.backgroundClip, b (function () {var n, r, a, s = "padding : 0; margin: 0; border: 0; display: block; cuadro de dimensionamiento: el contenido de la caja; -moz-box-calibrado: el contenido de la caja; -webkit-box-calibrado: el contenido de la caja; ", u = O .getElementsByTagName ( "cuerpo") [0]; u && (n = o.createElement ( "div"), n.style.cssText = "border: 0; anchura: 0; altura: 0; position: absolute; top: 0 ; left: -9999px; margin-top: 1px ", u.appendChild (n) .appendChild (d), d.innerHTML =" <table> <tr> <td> </ td> <td> t </ td > </ tr> </ table> ", a = d.getElementsByTagName (" TD "), a [0] .style.cssText =" padding: 0; margin: 0; border: 0; display: none ", p = 0 === a [0] .offsetHeight, a [0] .style.display = "", un [1] .style.display = "none", t.reliableHiddenOffsets p = 0 && === a [0]. offsetHeight, d.innerHTML = "", d.style.cssText = "caja de dimensionamiento: frontera de la caja; -moz-box-dimensionamiento: frontera-box; -webkit-box-dimensionamiento: frontera-box; padding: 1px; frontera: 1px; display: block; anchura: 4 píxeles; margin-top: 1%; position: absolute; top: 1%; ", t.boxSizing = 4 === d.offsetWidth, t.doesNotIncludeMarginInBodyOffset = 1 ==! u.offsetTop, e.getComputedStyle && (t.pixelPosition = "1%"! == (e.getComputedStyle (d, null) || {}). top, t.boxSizingReliable = "4PX" === (e.getComputedStyle (d, null) || {width: "4PX"}) de ancho, r = d.appendChild (o.createElement ( "div")), r.style.cssText = d.style.cssText = s, r.. style.marginRight = r.style.width = "0", d.style.width = "1px", t.reliableMarginRight =! parseFloat ((e.getComputedStyle (r, null) || {}). marginRight)), ! typeof d.style.zoom == i && (d.innerHTML = "", d.style.cssText = s + "width: 1px; padding: 1px; display: inline; zoom: 1", t.inlineBlockNeedsLayout = 3 == = d.offsetWidth, d.style.display = "bloque", d.innerHTML = "<div> </ div>", d.firstChild.style.width = "5px", t.shrinkWrapBlocks = 3! d == .offsetWidth, t.inlineBlockNeedsLayout && (u.style.zoom = 1)), u.removeChild (n), n = d = a = r = null)}), n = s = u = l = r = a = null (?: \ {[\ s \ S] * \} | \ [[\ s \ S] * \]);, t} () var O = / $ /, B = / ([AZ]) / g ; función P (e, n, r, i) {if (b.acceptData (e)) {var o, a, s = b.expando, u = "cadena" == typeof n, l = e.nodeType, p = l b.cache: e, f = l e [s]:??! e [s] && s; si (f && p [f] && (i || p [f] .data) || u || r ! == t) || retorno f (l e [s] = f = c.pop (?) || b.guid ++: f = s), p [f] || (p [f] = {}, l || (p [f] = .toJSON b.noop)), ( "objeto" == typeof n || "función" == typeof n) && (i? p [f] = b.extend (p [ f], n): p [f] = .data b.extend (p [f] .data, n)), o = p [f], i || (O.Data || (O.Data = { }), o = O.Data), r! == t && (O [b.camelCase (n)] = r), u? (a = o [n], null == a && (a = O [b. camelCase (n)])): a = O, a}} la función R (e, t, n) {if (b.acceptData (e)) {var r, i, o, a = e.nodeType, s = ? un b.cache: correo, u = un correo [b.expando]: b.expando; if (s [u]) {if (t && (o = n s [u]:?? s [u] .data )) {b.isArray (t) = t t.concat (b.map (t, b.camelCase)):?? t en o t = [t] :( t = b.camelCase (t), t = t en o [t]:? t.split ( "")); for (r = 0, i = t.length; i> r; r ++) eliminar o [t [r]]; if ((n!? $: b.isEmptyObject) (o)) return} (n || (eliminar s [u] .data, $ (s [u]))) && (un b.cleanData ([e] ,! 0)?: ! b.support.deleteExpando || s = s.window eliminar s [u]:? s [u] = null)}}} b.extend ({cache: {}, en Expansión: "jQuery" + (p + Matemáticas .random ()) sustituir (/ \ D / g, ""), nodata: {incrustar: 0, objeto: ". idcls: D27CDB6E-AE6D-11cf-96B8-444553540000", subprograma: 0}, HasData: función (e) {return e = e.nodeType b.cache [e [b.expando]]:? e [b.expando], e !! && $ (e)!}, los datos: function (e, t, n ) {return P (e, t, n)}, REMOVEDATA: function (e, t) {return R (e, t)}, _ los datos: function (e, t, n) {return P (e, t, n !, 0)}, _ REMOVEDATA: function (e, t) {return R (e, t, 0)}, acceptData: función (e) {if (e.nodeType && 1 == == e.nodeType && 9 e!!. nodeType) return 1;! var t = e.nodeName && b.noData [e.nodeName.toLowerCase ()];!!! volver t || t == 0 && e.getAttribute ( "classid") === t}}), b.fn.extend ({datos: function (e, n) {var r, i, o = esta [0], a = 0, s = null; si (e === t) {if (this.length && (s = B.Data (o), 1 === o.nodeType && b._data (O ", parsedAttrs")!)) {for (r = o.attributes; r.length> a; a ++) i = r [a] .name, i.indexOf ( "datos -") || (i = b.camelCase (i.slice (5)), W (O, I, s [i])); b._data (O , "parsedAttrs", 0)}} s de retorno de retorno "objeto" == typeof e this.each (function () {B.Data (esto, e)}):? b.access (esto, la función (n) {return n === t o W (O, e, B.Data (O, e)):?? nula: (this.each (function () {B.Data (esto, e, n)}), t)}, null, n, arguments.length> 1, nULL, 0)}, REMOVEDATA: función (e) {return this.each (function () {b.removeData (esto, e)})}}) ; la función W (e, n, r) {if (r === === t && 1 e.nodeType) {var i = "datos -" + n.replace (B, "- $ 1") toLowerCase (.); si (r = e.getAttribute (i), "cadena" == typeof r) {try {r = "true" === r 0:?! "falsa" === R1:?! "nulo" = ? r == null: + r + "" === R + R:? O.test (r) b.parseJSON (r):? r} catch (o) {} B.Data (e, n, r) } else r = t}} r retorno de la función $ (e) {var t; para (t en e) si (( "datos" == t || b.isEmptyObject (e [t])) && "toJSON! "! == t) return 1; return 0} b.extend! ({cola: function (e, n, r) {var i; vuelta de correo (n = (n ||!?" FX ") +" cola ! ", i = b._data (e, n), r && (i || b.isArray (r) i = b._data (e, n, b.makeArray (r)):? i.push (r) ), i || []): t}, quitar de la cola: function (e, t) = {t t || "fx"; var n = b.queue (e, t), r = n.length, i = n.shift (), o = b._queueHooks (e, t), a = function () {b.dequeue (e, t)}; "inprogress" === i && (i = n.shift (), r -), o.cur = i, i && ( "FX" === t && n.unshift ( "inprogress"), eliminar O.Stop, i.call (e, a, o)) ,! r && && o o.empty.fire ()}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; b._data retorno (e, n) || b._data (e, n, {vacías: b.Callbacks ( "una vez que la memoria ") .add (function () {b._removeData (e, t +" cola "), b._removeData (e, n)})})}}), b.fn.extend ({cola: function (e, : -, retorno "cadena" = typeof e && (n = e e = "FX", r), r> arguments.length b.queue (esto [0], e); n) {var r = 2!? n === T este: this.each (function () {var t = b.queue (esto, e, n); b._queueHooks (esto, e), "fx" === e && "inprogress"?! == t [0] && b.dequeue (esto, e)})}, quitar de la cola: function (e) {return this.each (function () {b.dequeue (esto, e)})}, retardo: function ( e, t) {return e = b.fx b.fx.speeds [e] || e:? e, t = t || "FX", this.queue (t, la función (t, n) {var r = setTimeout (t, e); n.stop = function () {clearTimeout (r)}})}, clearQueue: function (e) {return this.queue (e || "FX", [])}, promesa : function (e, n) {var r, i = 1, o = b.Deferred (), a = esta función, s = this.length, u = () {- i || o.resolveWith (a, [a])}; "cadena" = typeof e && (n = e, e = t), e = e || "fx";! while (s -) r = b._data (una [s], e + "queueHooks"), r && && r.empty (i ++, r.empty.add (u)); return u (), o.promise (n)}}); var I, Z, X = / [\ t \ r \ n] / g, T = / \ r / g, V = / ^ (entrada ?: | selecto | área de texto botón | | objeto) $ / i, Y = / ^ (un ?: | área) $ / I, J = / ^ (comprobado ?: | seleccionadas | autofoco | reproducción automática | asíncrono | controles | Defer | discapacitados | hidden | bucle | múltiple | abierto | sólo lectura | requerida | scoped) $ / i, G = / ^ (comprobado ?: | seleccionado ) $ / i, Q = b.support.getSetAttribute, K = b.support.input; b.fn.extend ({attr: function (e, t) {b.access retorno (esto, b.attr, e, t, arguments.length> 1)}, removeAttr: function (e) {return this.each (function () {b.removeAttr (esto, e)})}, prop: function (e, t) {return b. de acceso (esto, b.prop, e, t, arguments.length> 1)}, removeProp: function (e) {return b.propFix e = [e] || e, this.each (function () {try { esta [e] = t, Suprimir esta [e]} catch (n) {}})}, addClass: function (e) {var t, n, r, i, o, a = 0, s = this.length , u = "string" == typeof e && e; si (b.isFunction (e)) volver this.each (función de (t) {b (esto) .addClass (e.call (esto, t, this.className)) }), si (u) para (t = (e || "") partido (w) || [];. s> a; a ++) si (n = esta [a], r = 1 === n .nodeType && (( "" + n.className + "") .Colocar n.className (X, ""): "?")) {o = 0, mientras que (i = t [o ++]) 0> r.indexOf ( "" + i + "") && (r + = i + ""); n.className = b.trim (r)}} devolver este, removeClass: function (e) {var t, n, r, i, o, una = 0, s = this.length, u = 0 === arguments.length || "cadena" == typeof correo electrónico &&; si (b.isFunction (e)) volver this.each (function (t) {b (esto ) .removeClass (e.call (esto, t, this.className))}); si (u) para (t = (e || "") partido (w) || [];. s> a; a ++ ) si (n = esta [a], r = 1 === && (( "" + n.className + "") .Colocar n.className n.nodeType (X, ""): "?")) {o = 0, mientras que (i = t [o] ++), mientras que (r.indexOf ( "" + i + "")> = 0) r = r.replace ( "" + i + "", ""); n.className = e ? b.trim (r): ""}} devolver este, toggleClass: function (e, t) {var n = typeof e, r = "booleano" == typeof t; volver b.isFunction (e) esto?. cada uno (function (n) {b (este) .toggleClass (e.call (esto, n, this.className, t), t)}): this.each (function () {if ( "cadena" === n) {var O, a = 0, s = b (este), u = t, l = e.match (w) || []; mientras que (O = l [a] ++) u = r u :!? s.hasClass (o), s [u "addClass": "removeClass"] (o)} else (n === i || "booleano" === n) && (this.className && b._data (esto, "__className __", this.className), this.className = this.className || e === 1 "!?": b._data (esto ", __ __ className") || "")})}, hasClass: función (e) {var t = "" + e + "", n = 0, r = this.length; para (; r> n; n ++) si (1 === esta [n] .nodeType && ( "" + este [n] .className + "") .Colocar (X, "") .indexOf (t)> = 0) return 0;} return 1, val:!! función (e) {var n, r, i, o = esta [0]; {if (arguments.length) de retorno i = b.isFunction (e), this.each (function (n) {var o, a = b (este); 1 === this.nodeType && (O = i e.call (esto, n, a.val ()):? e, nula o o == = "?": "número" == typeof o o + =? "": b.isArray (o) && (o = b.map (O, la función (e) {return null == e "?": e + ""})), r = b.valHooks [this.type] || [b.valHooks this.nodeName. toLowerCase ()], r && "set" en r && r.set (esto, o, "valor") == || t (this.value = O)));} if (o) de retorno r = b.valHooks [ o.type] || b.valHooks [o.nodeName.toLowerCase ()], r && "llegar" en r && (n = r.get (o "valor")) == t n:? (n = o .value, "cadena" == typeof n n.replace (U ","): null == n? "?": n)}}}), b.extend ({valHooks: {opción: {get: función {!? var t = e.attributes.value; return t || t.specified e.value: e.text} (e)}, seleccione: {get: function (e) {var t, n, r = e .OPTIONS, i = e.selectedIndex, o = "select-uno" === e.type || 0> i, a = o nulo:? [], s = o i + 1:? r.length, u = 0> i s: S:?? 0; for (; s> u, u ++) si (n = r [u], (n.selected && u == i || (b.support.optDisabled!!!? n.disabled: nula == n.getAttribute ( "desactivado")) || n.parentNode.disabled && b.nodeName (n.parentNode, "optgroup"))) {if (t = b (n) .val () , o) de retorno t; a.push (t)}} devolver una, establecer: function (e, t) {var n = b.makeArray (t); b retorno (e) .find ( "opción") cada una. (function () {this.selected = b.inArray (b (este) .val (), n)> = 0}), n.length || (e.selectedIndex = -1), n}}}, attr :? función (e, n, r) {var O, a, S, T = e.nodeType; if (!!! e && && 3 == u 8 == == 2 && u u) volver typeof e.getAttribute === i b .prop (e, n, r) :( a = 1! == u ||! b.isXMLDoc (e), a && (n = n.toLowerCase (), o = b.attrHooks [n] || (J ? .test (n) z:? I)), r === t o && && un "get" en O && nula == (s = o.get (e, n)) s:!?! (typeof e.getAttribute == i && (s = e.getAttribute (n)), == null s t:? s):!?! == r o nula && && un "conjunto" en O && (s = o.set (e, r, n)) = ? t = s: (e.setAttribute (n, r + ""), r) :( b.removeAttr (e, n), t))}, removeAttr: function (e, t) {var n, r, i = 0, o = t && t.match (w), si (o && 1 === e.nodeType), mientras que (n = o [i ++]) r = b.propFix [n] || n, J.test (n)? ! Q && G.test (n) e [b.camelCase ( "default -" + n)] = e [r] = 1: [R] e = 1: b.attr (e, n, "")! , e.removeAttribute (Q n:? r)}, attrHooks: {type: {conjunto: function (e, t) {if (b.support.radioValue && "radio" === t && b.nodeName (e, "de entrada! ")) {var n = e.value; volver e.setAttribute (" tipo ", t), n && (e.value = n), t}}}}, propFix: {tabindex:" tabIndex ", de sólo lectura:" readOnly "," para ":" htmlFor "," clase ":" className ", maxlength:" maxLength ", espaciado de celda:" cellSpacing ", cellpadding:" cellPadding ", rowspan:" rOWSPAN ", colspan:" colspan ", usemap : "usemap", frameborder: "frameBorder", contenteditable: "contentEditable"}, prop: la función (e, n, r) {var i, o, a, s = e.nodeType; si (e && 3 == s && 8! == s && 2! == s) volver a = 1! == s ||! b.isXMLDoc (e), a && (n = b.propFix [n] || n, o = b.propHooks [n]), !?! r == t o && "set" en O && (i = o.set (e, r, n)) == T i:? e [n] = r: o && "llegar" en O && nula == (! ? i = o.get (e, n)) I: e [n]}, {propHooks: tabIndex: {get: function (e) {var n = e.getAttributeNode ( "tabindex"), el retorno n && n.specified? parseInt (n.value, 10): V.test (e.nodeName) || Y.test (e.nodeName) && e.href 0:? t}}}}), z = {get: function (e, n ) {var r = b.prop (e, n), i = "booleano" == typeof && r e.getAttribute (n), o = "booleano" == typeof r K && Q nula =? i:?! G.test ( n) e [b.camelCase ( "default -" + n)]: i !!:?!? e.getAttributeNode (n); return o && o.value == 1 n.toLowerCase (): t}, sistema: función (e, t, n) {return t === 1 b.removeAttr (e, n):!?!?! K && || Q G.test (n) e.setAttribute (Q && b.propFix [n] || n, n): e [b.camelCase ( "default -" + n)] = e [n] = 0, n}}, K && || Q (b.attrHooks.value = {get: function (e, n ) {var r = e.getAttributeNode (n); return b.nodeName (e, "entrada") e.defaultValue: r && r.specified r.value: t??}, establezca: function (e, n, r) { volver b.nodeName (e, "entrada") (e.defaultValue = n, t):? me && I.set (e, n, r)}}), Q || (I = b.valHooks.button = {llegar : function (e, n) {var r = e.getAttributeNode (n); r retorno && ( "id" === n || "nombre" === n || "coordenadas" === n ""?! ? == r.value: r.specified) r.value: t}, establezca: function (e, n, r) {var i = e.getAttributeNode (r); retorno i || e.setAttributeNode (i = e .ownerDocument.createAttribute (r)), i.value = n + = "", "valor" === === r || n e.getAttribute (r) n:? t}}, b.attrHooks.contenteditable = {get: I.get, establezca: function (e, t, n) {I.set (e "," === t1:?! t, n)}}, b.each ([ "ancho", "altura"], la función (e, n) {b.attrHooks [n] = b.extend (b.attrHooks [n], {set:? función (e, r) {return "" === r (e .setAttribute (n, "auto"), r): t}})})), b.support.hrefNormalized || (b.each ([ "href", "src", "ancho", "altura"] , la función (e, n) {b.attrHooks [n] = b.extend (b.attrHooks [n], {get: function (e) {var r = e.getAttribute (n, 2); retorno nula == r t:? r}})}), b.each ([ "href", "src"], la función (e, t) {b.propHooks [t] = {get: function (e) {vuelta de correo. getAttribute (t, 4)}}})), b.support.style || (b.attrHooks.style = {get: function (e) {return e.style.cssText || t}, establezca: function (e , t) {return e.style.cssText = t + ""}}), b.support.optSelected || (b.propHooks.selected = b.extend (b.propHooks.selected, {llegar: function (e) { var t = e.parentNode; retorno t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null}})), b.support.enctype || (b.propFix.enctype = "codificación"), b. support.checkOn || b.each [ "radio", "casilla de verificación"], function () {b.valHooks [esto] = {get (: function (e) {return nula === e.getAttribute ( "valor" ) "en":? e.value}}}), b.each ([ "radio", "casilla de verificación"], function () {b.valHooks [esto] = b.extend (b.valHooks [esto], {set: function (e, n) {return b.isArray (n) = e.checked b.inArray (b (e) .val (), n)> = 0:? t}})}); var Z = / ^ (entrada ?: | selecto | área de texto) $ / i, y = / ^ tecla /, tt = / ^ (ratón ?: | contextual) | pulse /, nt = / ^ (focusinfocus ?: | focusoutblur) $ /,rt=/^([^.]*)(?:\.(.+)|)$/;function que () {return 0} function ot () {return! 1} = {b.event mundial: {}, añadir: function (e, n, r, o, a) {var s, u, L, C, P, F, d, h, g, m, y, v = b._data (e ); si (v) {r.handler && (c = r, r = c.handler, a = c.selector), r.guid || (r.guid = b.guid ++), (u = v.events) || (u = v.events = {}), (f = v.handle) || (f = v.handle = function (e) {return typeof b === i || e && b.event.triggered == t = e.type:? b.event.dispatch.apply (f.elem, argumentos)}, f.elem = e), n = (n || "".) partido (w) || [ ""] , l = n.length; while (l -) s = rt.exec (n [l]) || [], G = Y = s [1], m = s ([2] || "") .split ( ".") sort (), p = b.event.special [g] || {}, g =. (un p.delegateType:? p.bindType) || g, p = b.event. especial [g] || {}, d = b.extend ({tipo: g, origType: y, de datos: o, manejador: r, GUID: r.guid, selector: una, needsContext: un b.expr.match &&. needsContext.test (a), espacio de nombres: m.join ( ".")}, c), (h = u [g]) || (h = u [g] = [], h.delegateCount = 0, p .SETUP && p.setup.call (e, o, m, f) == 1 || (e.addEventListener e.addEventListener (g, F, 1):!?! e.attachEvent && e.attachEvent ( "on" + g , f))), p.add && (p.add.call (e, d), d.handler.guid || (d.handler.guid = r.guid)), un? h.splice (h.delegateCount ++ , 0, d): h.push (d), b.event.global [g] = 0; e = null}}, remover: function (e, t, n, r, i) {var O, a , s, u, l, c, p, f, d, h, g, m = b.hasData (e) && b._data (e), si (m && (C = m.events)) {t = (t || "".) partido (w) || [ ""], l = t.length, mientras que (l -) si (s = rt.exec (t [l]) || [], d = g = s [1], (h = s [2] || ""). split ( "."). sort (), d) {p = b.event.special [d] || {}, d = (? r p.delegateType: p.bindType) || d, f = c [d] || [], s = s [2] && RegExp (| + h.join ( "\" (^ \\). " \ (:.?. * \\..! |) ") +" (\\ | $) "), U = o = f.length, mientras que (o -) a = f [o] ,! i && g == a.origType || n && n.guid ! == a.guid || s &&! s.test (a.namespace) || r r &&! == a.selector && ( "**"! == r ||! a.selector) || (f.splice ( O, 1), a.selector && f.delegateCount -, p.remove && p.remove.call (e, a)); u && && f.length (p.teardown && p.teardown.call (e, h, m.handle)! ==! 1 || b.removeEvent (e, d, m.handle), borrar C [d])} else para (d de c) b.event.remove (e, d + t [l], n, ! r, 0); b.isEmptyObject (c) && (borrar m.handle, b._removeData (e, "eventos"))}}, disparador: function (n, r, i, a) {var s, u , L, C, P, F, d, h = [i || o], g = y.call (n, "tipo") n.type:? n, m = y.call (n, "espacio de nombres" ) n.namespace.split ()? ".":!!! []; si (l = f = i = i || O, 3 == == 8 i.nodeType && && i.nodeType nt.test (g + b .event.triggered) && (g.indexOf ( ".")> = 0 && (m = g.split ( "."), g = m.shift (), m.sort ()), u = 0> g .indexOf ( ":") && "en" + g, n = n [b.expando] n:? nueva b.Event (g, "objeto" == typeof n && n), n.isTrigger = 0, n!. namespace = m.join ( "."), n.namespace_re = n.namespace RegExp ( "(^ | \\)." + m.join ( "\\ (:.?.. * \\ |)"? ) + "(\\ | $)."):? nula, n.result = t, n.target || (n.target = i), r = null == r [n]: b.makeArray (r , [n]), p = b.event.special [g] || {}, a ||! p.trigger || p.trigger.apply (i, r)! ==! 1)) {if ( ! a && && p.noBubble b.isWindow (i)) {for (c = p.delegateType || g, nt.test (c + g) || (l = l.parentNode);! l; l = l. parentNode) h.push (l), f = l; f === (i.ownerDocument || O) && h.push (f.defaultView || || f.parentWindow e)} d = 0; while ((l = h [d ++]) && n.isPropagationStopped ()) n.type = d> 1 c:!? p.bindType || g, s = (b._data (l, "eventos") || {}) [ n.type] && b._data (l, "manejar"), s && s.apply (l, r), s = u && l [u], s && b.acceptData (l) && && s.apply s.apply (L, R) === ! 1 && n.preventDefault ();! if (! n.type = g, (a || n.isDefaultPrevented () || p._default && p._default.apply (i.ownerDocument, r) == 1 || "clic "=== g && b.nodeName (i," a ") ||! b.acceptData (i) ||! u ||! i [g] || b.isWindow (i))) {f = i [u ], f && (i [u] = null), b.event.triggered = g; try {i [g] ()} catch (v) {} b.event.triggered = t, f && (i [u] = f)}}} n.result de retorno, de expedición: function (e) {e = b.event.fix (e); var n, r, i, o, a, s = [], u = h.call ( argumentos), L = (b._data (esto, los "eventos") || {}) [e.type] || [], c = b.event.special [e.type] || {}; if ( u [0] = e, e.delegateTarget = este,! c.preDispatch || c.preDispatch.call (esto, e)! ==! 1) {s = b.event.handlers.call (esto, e, l), n = 0; while ((O = s [n ++]) && e.isPropagationStopped ()) {e.currentTarget = o.elem, a = 0;! while ((i = o.handlers [a ++]) &&! e.isImmediatePropagationStopped ()) (! e.namespace_re || e.namespace_re.test (i.namespace)) && (e.handleObj = i, e.data = I.Data, r = ((b.event. especial [i.origType] || {}). || manejar i.handler) .apply (o.elem, u), r! == t && (e.result = r) ===! 1 && (e.preventDefault (), e.stopPropagation ()))} return c.postDispatch && c.postDispatch.call (esto, e), e.result}}, manipuladores: function (e, n) {var r, i, o, a, s = [], u = n.delegateCount, l = e.target; if (! u && && l.nodeType (e.button || "clic" == e.type)!) para (;! l = presente; l = l .parentNode || esto) if (!!! 1 === l.nodeType && (l.disabled == 0 || "clic" == e.type)) {for (o = [], a = 0; u > a; a ++) i = n [a], r = i.selector + "", o [r] === t && (? o [r] = i.needsContext b (r, este) .index (l)> = 0: b.find (r, esto, nula, [l]) de longitud), o [r] && o.push (i); o.length && s.push (. {elem: l, manipuladores: o})} return n.length> u && s.push ({elem: esto, los manipuladores: n.slice (u)}), s}, fijar: function (e) {if (e [b.expando]) declaración electrónica; var t, n , r, i = e.type, a = e, s = this.fixHooks [i]; s || (this.fixHooks [i] = s = tt.test (i) this.mouseHooks: et.test (? ? i) this.keyHooks: {}), r = s.props this.props.concat (s.props): this.props, e = nuevo b.Event (a), t = r.length, mientras que (? t -) n = r [t], e [n] = a [n]; volver e.target || (e.target = || a.srcElement o), 3 === e.target.nodeType && ( ? e.target = e.target.parentNode), e.metaKey = !! e.metaKey, s.filter s.filter (e, a): e}, apoyos: "altKey burbujas objetivo cancelable ctrlKey currentTarget eventPhase metakey relatedTarget shiftKey Ver timeStamp la que ".split (" "), fixHooks: {}, keyHooks: {apoyos:" char charCode keyCode clave ".split (" "), filtro: function (e, t) {return nula == e.which && (e.which = null = t.charCode t.charCode:!? t.keyCode), e}}, mouseHooks: {apoyos: "botones botón clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement" .split ( "") , filtro: function (e, n) {var r, i, a, s = n.button, u = n.fromElement; retorno nula == null = e.pageX && && n.clientX (i = e.target.ownerDocument |! | O, a = i.documentElement, r = i.body, e.pageX = n.clientX + (a && a.scrollLeft || R || && r.scrollLeft 0) - (a && a.clientLeft || R || && r.clientLeft 0), e.pageY = n.clientY + (a && a.scrollTop || R || && r.scrollTop 0) - (a && a.clientTop || R || && r.clientTop 0)) ,! e.relatedTarget && && T (e.relatedTarget = u === correo .target n.toElement:? u), e.which || s || t === (e.which s = 1 & 1: 2 y 3 s:? 4 & s 2: 0), e}}, especial: {carga : {noBubble: 0}, haga clic en: {gatillo: function () {return b.nodeName (esto "entrada") && "casilla de verificación" === this.type && this.click (this.click () ,! 1? ): t}}, se centran: {gatillo: function () {if (esto == o.activeElement && this.focus) {return tratar this.focus () ,! 1!} catch (e) {}}, delegateType: " focusIn "}, falta de definición: {gatillo: function () {return esta === o.activeElement && this.blur (this.blur () ,! 1):? t}, delegateType:" focusOut "}, beforeunload: {postDispatch: función (e) {e.result == t && (e.originalEvent.returnValue = e.result)!}}}, simular: function (e, t, n, r) {var i = b.extend (nueva b. evento, n, {! tipo: e, isSimulated: 0, originalEvent: {}}); r b.event.trigger (i, null, t):? b.event.dispatch.call (t, i), i .isDefaultPrevented () && n.preventDefault ()}}, b.removeEvent = o.removeEventListener función (e, t, n) {e.removeEventListener && e.removeEventListener (t, n, 1!)}:? función (e, t, n) {var r = "on" + t; e.detachEvent && (typeof e [r] === i && (e [r] = null), e.detachEvent (r, n))}, b.Event = function (e, n) {return este instanceof b.Event? (e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = || e.defaultPrevented e.returnValue ===! 1 || e.getPreventDefault && e.getPreventDefault () es:? OT): this.type = e, n && b.extend (esto, n), this.timeStamp = e && || b.now e.timeStamp (), esta [b.expando ] = 0, t): nueva b.Event (e, n)}, {b.Event.prototype = isDefaultPrevented: OT, isPropagationStopped: OT, isImmediatePropagationStopped: OT, preventDefault: function () {var e = this.originalEvent ; this.isDefaultPrevented = ella, e && (e.preventDefault e.preventDefault (): e.returnValue = 1?!)}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = ella, e && (e .stopPropagation && e.stopPropagation (), e.cancelBubble = 0)}, stopImmediatePropagation: function () {= this.isImmediatePropagationStopped que, this.stopPropagation ()}}, b.each ({MouseEnter: "mouseover", mouseleave: " mouseout "}, la función (e, t) {b.event.special [e] = {delegateType: t, bindType: t, manejar: function (e) {var n, r = este, i = e.relatedTarget, o = e.handleObj;
retorno (! i || i! == r &&! b.contains (r, i)) && (e.type = o.origType, n = o.handler.apply (esto, los argumentos), e.type = t) , n}}}), b.support.submitBubbles || (b.event.special.submit = {configuración: function () {return b.nodeName (esto, "forma") ?! 1: (b.event. añadir (esto "click._submit keypress._submit", la función (e) {var n = e.target, r = b.nodeName (n, "entrada") || b.nodeName (n, "botón")? n.form: t; r && b._data (r, "submitBubbles") && (b.event.add (r, "submit._submit", la función (e) {e._submit_bubble = 0}), b. _data (r, "submitBubbles", 0))}), t)}, postDispatch: function (e) {e._submit_bubble && (eliminar e._submit_bubble, this.parentNode &&! E.isTrigger && b.event.simulate ( "submit", this.parentNode, e, 0))}, desmontaje: function () {return b.nodeName (esto, "forma") ?! 1: (b.event .Remove (esto "._ submit"), t)}}), b.support.changeBubbles || (b.event.special.change = {configuración: function () {return Z.test (this.nodeName)? (( "casilla de verificación" === this.type || "radio" === this.type) && (b.event.add (esto "propertychange._change", la función (e) { "marcada" === e.originalEvent.propertyName && (this._just_changed = 0)}), b.event.add (esto "click._change", la función (e) {this._just_changed &&! e.isTrigger && (this._just_changed =! 1) , b.event.simulate ( "cambio", esto, e, 0)})) ,! 1) :( b.event.add (esto "beforeactivate._change", la función (e) {var t = e .target;! Z.test (t.nodeName) && b._data (t, "changeBubbles") && (b.event.add (t, "change._change", la función (e) {this.parentNode || e.isSimulated || || e.isTrigger b.event.simulate ( "cambio", this.parentNode, e, 0)}), b._data (t, "changeBubbles", 0))}), t )}, manejar:!!! función (e) {var n = e.target; devuelva esta == || n || e.isSimulated e.isTrigger || "radio" == n.type && "casilla de verificación" == n.type e.handleObj.handler.apply (esto, argumentos):? t}, desmontaje: function () {b.event.remove retorno (esto "._ cambio") ,! Z.test (this.nodeName) }}), b.support.focusinBubbles || b.each ({enfoque: "focusin", falta de definición: "focusOut"}, la función (e, t) {var n = 0, r = function (e) {b. event.simulate (t, e.target, b.event.fix (e) ,! 0)}; b.event.special [t] = {configuración: function () {0 === n ++ && o.addEventListener (! e, r, 0)}, desmontaje: function () {0 === - n && o.removeEventListener (e, r, 0)}}}), b.fn.extend ({on: function (e , n, r, i, o) {var a, s, y si ( "objeto" == typeof e) { "cadena" = typeof n && (r = r || n, n = t);! a (una en e) this.on (a, n, r, e [a], o); devuelva esta} if (null && r == == nula i (i = n, r = n = t?): == null && i ( "cadena" == typeof n (i = r, r = t) :( i = r, r = n, n = t)), i === 1) i = ot;?! else if (i) devolver este, y devuelve 1 === O && (s = i, i = function (e), i.guid = s.guid || {return b () fuera (e), s.apply (este, argumentos).} (s.guid = b.guid ++)), this.each (function () {b.event.add (esto, e, i, r, n)})}, uno: function (e, t, n, r ) {return this.on (e, t, n, r, 1)}, fuera: function (e, n, r) {var i, o, si (e && && e.preventDefault e.handleObj) de retorno i = e.handleObj, b (e.delegateTarget) .OFF (i.namespace i.origType + + i.namespace? ".": i.origType, i.selector, i.handler), esto, si ( "objeto" == typeof e) { para (o en e) this.off (o, n, e [o]);} devuelva este retorno (n === 1 || "función" == typeof n) && (r = n, n = t ), r === 1 && (r = ot), this.each (function () {b.event.remove (esto, e, r, n)})}, se unen: la función (e, t, n) {return this.on (e, null, t, n)}, desenlazar: function (e, t) {return this.off (e, null, t)}, delegado: function (e, t, n, r) {return this.on (t, e, n, r)}, undelegate: function (e, t, n) {return (, e "**") 1 === arguments.length this.off:? esto. apagado (t, e || "**", n)}, disparador: function (e, t) {return this.each (function () {b.event.trigger (e, t, this)})}, triggerHandler: function (e, n) {; var r = esta [0] retorno b.event.trigger (! e, n, r, 0) r: t?}}), función (e, t) {var n , r, i, o, a, s, u, L, C, P, F, d, h, g, m, y, v, x = "chisporroteo" + - nueva fecha, w = e.document, T = {}, N = 0, C = 0, k = it (), E = it (), S = que (), A = typeof t, j = 1 << 31, D = [], L = D .pop, H = D.push, q = D.slice, M = D.indexOf función || (e) {var t = 0, n = this.length; para (; n> t; t ++) si (esto [t] === e) de retorno t; return-1}, _ = "[\\ x20 \\ t \\ r \\ n \\ f]", M = "(?:. \\\\ | [\\ W] | [^ \\ x00 - \\ xa0]) + ", O = F.replace (" w "," w # "), B =" ([* ^ $ | ~!]? =) ", p =" \\ [ "+ _ +" * ( "+ F +") "+ _ +" * (?: "+ B + _ +" * (?: ([ '\ "]) ( ? (?:. \\\\ | [^ \\\\]) *) \\ 3 | ( "+ O +") |) |) "+ _ +" * \\] ", R =" :( "+ F +") (: \\ ((([ '\ "]) ((: \\\\ | [^ \\\\]) *) \\ 3 | ((?:?.?? \\ \\ |. [^ \\\\ () [\\]] | "+ P.replace (3,8) +") *) | *.) \\) |) ", W = RegExp (" ^ "+ _ +" + | ((?:?. ^ | [^ \\\\]) (: \\\\) *) "+ _ +" + $ "," g "), $ = RegExp ( "^" + _ + "*" + _ + "*"), I = RegExp ( "^" + _ + "* ([\\ x20 \\ t \\ r \\ n \\ f> + ~ ]) "+ _ +" * "), z = RegExp (R), X = RegExp (" ^ "+ O +" $ "), T = {ID: RegExp (" ^ # ( "+ F +") ") , CLASE: RegExp ( "^ \\ (". + F + ")"), nOMBRE:? RegExp ( "^ \\ [nombre = [ '? \"] ( "+ F +") [' \ "] \\ ] "), TAG: RegExp (" ^ ( "+ F.replace (" w "," w * ") +") "), ATTR: RegExp (" ^ "+ P), PSEUDO: RegExp (" ^ " + R), nIÑO: RegExp ( "^ :( única | primera | última | enésima | enésima última) - (niño | de tipo a) (?: \\ (" + _ + "* (incluso | extraño | ( ([+ -] |) (d \\ *) n |) "+ _ +" * (?: ([+ -] |) "+ _ +" * (\\ d +) |)) "+ _ + "* \\) |)", "i"), needsContext: RegExp ( "^" + _ + "* [> + ~] |: (incluso | extraño | eq | GT | lt | enésima | primera | última) (: \\ ( "+ _ +" * ((: -??? \\ d) \\ * d) "+ _ +" * \\) |) (? = [^ -] | $) ", "i")}, V = / [\ x20 \ t \ r \ n \ f] * [+ ~] /, Y = / ^ [^ {] + \ {\ s * código nativo \ [/, J = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,G=/^(?:input|select|textarea|button)$ / i, Q = / ^ h \ d $ / I, K = / '| \\ / g, Z = / \ = [\ x20 \ t \ r \ n \ f] * ([^' "\]] *) [\ x20 \ t \ r \ n \ f] * \] / g, et = / \\ ([\ da-FA-F] {1,6} [\ x20 \ t \ r \ n \ f ?.?!?] |) / g, tt = function (e, t) {var n = "0 x" + t-65536; n de retorno == n t: 0> n String.fromCharCode (n + 65536): String.fromCharCode (55296 | n >> 10,56320 | 1023 & N)}; try {q.call (w.documentElement.childNodes, 0) [0] .nodeType} catch (nt) {q = function (e) {var t, n = []; tiempo (t = esta [e ++]) n.push (t); retorno n}} function rt (e) {return función que () {var e Y.test (e + "")} , t = []; e devolver = function (n, r) {t.push retorno (n + = "") eliminar e, e = r> i.cacheLength && [t.shift ()] [n]}} function ot ( e) {return e [x] = 0 e,!} en función de (e) {var t = p.createElement ( "div"); try {retorno e (t)} catch (n) {return 1} por fin! {t = null}} st función (e, t, n, r) {var i, o, a, s, u, l, f, g, m, v;? if ((t t t.ownerDocument || :! w) == p && c (t), t = t || p, n = n || [] ,! e || "string" = typeof e regreso) n; si (1 == (s = t.nodeType) && 9 == s) volver []; if (! d && r) {if (i = J.exec (e)) si (a = i [1]) {if (9 === s! ) {if (o = t.getElementById (a) ,! O || o.parentNode) de retorno n; if (! o.id === a) la devolución n.push (o), n} else if (t. ownerDocument && (o = t.ownerDocument.getElementById (a)) && y (t, o) && o.id === a) la devolución n.push (o), n} else {if (i [2]) devuélvalo H.apply (n, q.call (t.getElementsByTagName (e), 0)), n; if ((a = i [3]) && && T.getByClassName t.getElementsByClassName) devuélvalo H.apply (n, q.call (t.getElementsByClassName (a), 0)), n} Si (T.qsa &&! h.test (e)) {if (f = 0, g = x, m = t, v = 9 === s && e, 1 == = s && "objeto"! == t.nodeName.toLowerCase ()) {l = pi (e), (f = t.getAttribute ( "id"))? g = f.replace (K, "\\ $ & "): t.setAttribute (" id ", g), g =" [id = "" + g + " ']", u = l.length, mientras que (u -) l [u] = g + dt ( l [u]); m = V.test (e) && t.parentNode || t, v = l.join ( ",")} if (v) {return tratar H.apply (n, q.call (m .querySelectorAll (v), 0)), n} catch (b) {} finally {f || t.removeAttribute ( "id")}}} return en peso (e.replace (W, "$ 1"), t, n, r)} a = st.isXML = function (e) {var t = e && (e.ownerDocument || e) .documentElement; t retorno "HTML" == t.nodeName:?!! 1}, c = st.setDocument = function (e) {var n = e e.ownerDocument || e:?!? w; n de retorno == p && && 9 === n.nodeType n.documentElement (p = n, f = n.documentElement, d = a (n), en T.tagNameNoComments = (function (e) {return e.appendChild (n.createComment ( "")) ,! e.getElementsByTagName ( "*"). longitud}), T.attributes = a (function (e) {e.innerHTML = "<select> </ select>"; var t = typeof e.lastChild.getAttribute ( "múltiple");! retorno "booleano" == t && "cadena" t == }), T.getByClassName = a (function (e) {return e.innerHTML = "<div class =" oculto e '> </ div> <div class = "oculto"> </ div> ", e.getElementsByClassName && correo .getElementsByClassName ( "e"). longitud? (e.lastChild.className = "e", 2 === e.getElementsByClassName ( "e"). de longitud) :! 1}), en T.getByName = (function ( e) {e.id = x + 0, e.innerHTML = "<a name='"+x+"'> </a> <div name = '" + x + ""> </ div> ", f. insertBefore (e, f.firstChild); var t = n.getElementsByName && n.getElementsByName (x) 2 + === .length n.getElementsByName (x + 0) .length; directo volver T.getIdNotName = n.getElementById (x) , f.removeChild (e), t}), i.attrHandle = a (function (e) {return e.innerHTML = "<a href='#'> </a>", e.firstChild && typeof e.firstChild. ! == getAttribute A && "#" === e.firstChild.getAttribute ( "href")}) {}: {href: function (e) {return e.getAttribute ( "href", 2)}, escriba: función (e) {return e.getAttribute ( "tipo")}}, T.getIdNotName? (i.find.ID = function (e, t) {if (typeof t.getElementById! == Un &&! d) {var n = t.getElementById (e); retorno n && n.parentNode [n]: []}}, i.filter.ID = function (e) {var t = e.replace (eT, TT); función de retorno (e ) {return e.getAttribute ( "id") === t}}) :( i.find.ID = function (e, n) {if (typeof n.getElementById! == Un &&! d) {var r = n.getElementById (e); r retorno r.id === e || typeof r.getAttributeNode == Un && r.getAttributeNode ( "id") === valor e [r]:?!.? t: []} }, i.filter.ID = function (e) {var t = e.replace (eT, TT);! función de retorno (e) {var n = e.getAttributeNode typeof == Un && e.getAttributeNode ( "id"); volver n && n.value === t}}), i.find.TAG = T.tagNameNoComments función (e, n) {return typeof n.getElementsByTagName == Un n.getElementsByTagName (e):?!? T}: función (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e), si ( "*" === e) {while (n = S [i] ++) 1 == !? = n.nodeType && r.push (n); retorno de la función, i.find.NAME = T.getByName && r} return o} (e, n) {return typeof n.getElementsByName == Un n.getElementsByName (nombre): t }, i.find.CLASS = T.getByClassName && función (e, n) {return typeof n.getElementsByClassName === A || d t:? n.getElementsByClassName (e)}, g = [], h = [ ": enfoque "], (T.qsa = rt (n.querySelectorAll)) && (al (function (e) {e.innerHTML =" <select> <option selected = ''> </ option> </ select> ", . e.querySelectorAll ( "[seleccionado]") de longitud || h.push ( "\\ [" + _ + "* (comprobado ?: | discapacitados | ismap | múltiple | sólo lectura | seleccionadas | valor)"), e. querySelectorAll ( ": comprueba") de longitud || h.push ( ": comprueba").}), en (function (e) {e.innerHTML = "<input type =" oculto "i = '' />", e.querySelectorAll ( "[i ^ = '']") && longitud h.push ( "[* ^ $] =" + _ + "* (?: \" \ "|. '')"), e.querySelectorAll ( ": habilitado") de longitud || h.push (. ": habilitado", ": desactivado"), e.querySelectorAll ( "* ,: x"), h.push ( "*:.")})) , (T.matchesSelector = rt (m = f.matchesSelector || || f.mozMatchesSelector f.webkitMatchesSelector || || f.oMatchesSelector f.msMatchesSelector)) && al (function (e) {T.disconnectedMatch = m.call ( e "div"), m.call (e, "[s = ''!]: x"), g.push (R)}), h = RegExp (h.join ( "|" =! " ")), g = RegExp (g.join (" |? ")), y = RT (f.contains) || f.compareDocumentPosition función (e, t) {var n = 9 === e.nodeType? e.documentElement: e, r = t && t.parentNode; vuelta de correo === r || (r || 1 || == r.nodeType (n.contains n.contains (r): e!!!!?. compareDocumentPosition && 16 y e.compareDocumentPosition (r)))}: función (e, t) {if (t), mientras que (t = t.parentNode) si (t === e) return 0;} devuelven 1, v = f!. compareDocumentPosition función (e, t) {var r;??? vuelta de correo === t (! u = 0,0) :( r = t.compareDocumentPosition && && e.compareDocumentPosition e.compareDocumentPosition (t)) 1 & r || e.parentNode && 11 = ? == === e.parentNode.nodeType e n || y (w, e) - 1:? t === n || y (w, t) 1: 0: 4 & r -1: 1:?? ? e.compareDocumentPosition -1: 1}: function (e, t) {var r, i = 0, o = e.parentNode, a = t.parentNode, s = [e], l = [t]; si ( e === t) u devolver = 0,0; si (O || a) la devolución de correo === n -1:!!!???? t === n 1: o -1: 1: 0; si (O === a) la devolución ut (e, t); r = e; mientras que (r = r.parentNode) s.unshift (r); r = t, mientras que (r = r.parentNode) l .unshift (r), mientras que (s [i] === l [i]) i ++; retorno i ut (s [i], L [i]):?? s [i] === w -1: l [i] === w 1: 0}, u = 1, [0,0] .Sort (v), T.detectDuplicates = u, p): p}, st.matches = function (e, t) {return st (e, null, null, t)}, st.matchesSelector = function (e, t) {if ((e.ownerDocument || e)! == p && c (e), t = t.replace (Z "= '$ 1']"),! (! T.matchesSelector || d || g && g.test (t) || h.test (t))) try {var n = m.call (e, t);!., si (n || || T.disconnectedMatch e.document && 11 == e.document.nodeType) de retorno n} catch (r) {} return st (t, p, nula, [e]) de longitud> 0}, st.contains = function (e, t) {return (e.ownerDocument || e)! == p && c (e), y (e, t)}, st.attr = function (e, t) { var n; retorno (e.ownerDocument || e) == p && c (e), d || (t = t.toLowerCase ()), (n = i.attrHandle [t]) n (e): d!? || T.attributes e.getAttribute (t):? ((n = e.getAttributeNode (t)) || e.getAttribute (t)) && e [t] === 0 t:?!? n && n.specified n .value: null}, st.error = function (e) {tiro de error ( "error de sintaxis, la expresión no reconocida:" + e)}, st.uniqueSort = function (e) {var t, n = [], r = 1, i = 0; si (u = T.detectDuplicates, e.sort (v), u!) {for (; t = e [r]; r ++) t === e [r-1] && (i = n.push (r)), mientras que (i -) e.splice (n [i], 1)}} declaración electrónica; ut función (e, t) {var n = t && e, r = n && (t ~ .sourceIndex || j) - (~ e.sourceIndex || j), si (r) r retorno; si (n), mientras que (n = n.nextSibling) si (n === t) volver-1; return correo ? 1: -1} function lt (e) {función de retorno (t) {var n = t.nodeName.toLowerCase (); return "entrada" === === n && Ttipo e}} function ct (e) {función de retorno (t) {var n = t.nodeName.toLowerCase (); return ( "entrada" === n || "botón" === n) && Ttipo === e}} function pt (e ) {return ot (function (t) {return t = + t, ot (function (n, r) {var i, o = e ([], n.length, t), a = o.length, mientras que ( a -) n [i = o [a]] && (n [i] = (r [i] = n [i]!))})})} o = st.getText = function (e) {var t, n = "", r = 0, i = e.nodeType; si (i) {if (1 === === i || 9 || i 11 === i) {if ( "cadena" == typeof e.textContent) e.textContent regreso, porque (e = e.firstChild; e; e = e.nextSibling) n + = o (e)} else if (3 === === i || 4 i ) volver e.nodeValue} else para (; t = e [r]; r ++) + n = o (t); retorno n}, i = st.selectors = {cacheLength: 50, createPseudo: OT, partido: T, encontrar : {}, relativa: { ">": {dir: "parentNode", en primer lugar: 0} ",": {dir: "parentNode"} "+": {dir: "previousSibling", en primer lugar: 0 }, "~": {dir: "previousSibling"}}, prefiltro: {ATTR: function (e) {return correo [1] = e [1] .Colocar (eT, TT), e [3] = (e [4] || e [5] || ""). replace (et, tt), "~ =" === e [2] && (e [3] = "" + e [3] + "" ), e.slice (0,4)}, NIÑO: function (e) {return correo [1] = e [1] .tolowercase (), "enésima" === e [1] .slice (0,3 ) (e [3] || st.error (e [0]), e [4] = + (e [4] e [5] + (e [6] || 1):?? 2 * ( " incluso "=== e [3] ||" extraño "e === [3])), e [5] = + (e [7] + e [8] ||" extraño "e === [ ! 3])): e [3] && st.error (e [0]), e}, PSEUDO: function (e) {var t, n = e [5] && e [2]; volver U.CHILD.test (e [0]) null:?? (e [4] e [2] = e [4]: ​​n && z.test (n) && (t = pi (n, 0)) && (t = n.indexOf ( ")", n.length-t) -n.length) && (e [0] = e [0] .slice (0, t), e [2] = n.slice (0, t)), e.slice (0,3))}}, filtro: {TAG:?! función (e) {return "*" === e function () {return 0} :( e = e.replace (eT, TT ) .tolowercase (), función (t) {return t.nodeName && t.nodeName.toLowerCase () === e})}, CLASE: function (e) {var t = k [e + ""]; return t || (t = RegExp ( "(^ |" + _ + ")" + e + "(" + _ + "| $)")) && k (e, la función (e) {return t.test (e.className || typeof e.getAttribute == Un && e.getAttribute ( "clase") || "")})}, ATTR: función (e, t, n) {función de retorno (r) {var i = st.attr (r, ? "! =?"; e) devolver null == === i t: t (i + = "", "=" === === t i n:? "=" === C I!? ! == n: "^ =" t N === === 0 && i.indexOf (n): "* =" === t N && i.indexOf (n)> - 1:?? "$ =" == = t n && i.slice (-n.length) === n: "~ =" === t ( "" + i + "") .indexOf (n)> - 1:?? "| =" === ? t i === n || i.slice (0, n.length + 1) === n + "-" :! 1) :! 0}}, NIÑO: function (e, t, n, r, !! i) {var o = "enésimo" == e.slice (0,3), a = "último" == e.slice (-4), s = "del tipo" === t; de retorno ? 1 === === r && 0 i función (e) {return !! e.parentNode}: función (t, n, u) {var l, c, p, f, d, h, g = o = ? = a "nextSibling": "previousSibling", m = t.parentNode, y = s && t.nodeName.toLowerCase (), v = u && s; si (m) {if (o) {while (g) {p! = t, mientras que (p = p [g]) si (s p.nodeName.toLowerCase () === y:? 1 === p.nodeType)! return 1; h = g = "sólo" === ! e && && h "nextSibling"} return 0} if (h = [a m.firstChild:? m.lastChild], a && v) {c = m [X] || (m [x] = {}), l = c [e] || [], d = l [0] === N && l [1], f = l [0] === N && l [2], p = d && m.childNodes [d], mientras que (p = ++ d && && p p [g] || (f = d = 0) || h.pop ()) si (1 === p.nodeType && && f ++ p === t) {c [e] = [N, d , f]; descanso}} else if (v && (l = (t [x] || (t [x] = {})) [e]) && l [0] === N) f = l [1] ; mientras que los demás (p = ++ d && && p p [g] || (f = d = 0) || h.pop ()) si ((s p.nodeName.toLowerCase () === y:? 1 === p.nodeType) && && ++ f (v && ((p [x] || (p [x] = {})) [e] = [N, f]), p === t)) romper; f retorno - = i, f r || === === f 0% && r f / r> = 0}}}, PSEUDO: function (e, t) {var n, r = i.pseudos [e] i || .setFilters [e.toLowerCase ()] || st.error ( "pseudo sin apoyo:" + e);?? r retorno [x] r (t): r.length> 1 (n = [e, e, " ", t], i.setFilters.hasOwnProperty (e.toLowerCase ()) ot (function (e, n) {var i, o = r (e, t), a = o.length;? while (A-- ) i = M.call (e, o [a]), e [i] = (n [i] = o [a])}): la función (e) {return r (e, 0, n)} ): r}}, pseudos: {no: OT (function (e) {var t = [], n = [], r = s (e.replace (W, "$ 1")); r retorno [x] ? ot (function (e, t, n, i) {var o, a = r (e, null, i, []), s = e.length; while (s -) (o = a [s] ) && (e [s] = (t [s] = o!))}): function (e, i, o) {return t [0] = e, r (t, nula, o, n) ,! n.pop ()}}), tiene: OT (function (e) {función de retorno (t) {return st (e, t) .length> 0}}), contiene: OT (function (e) {función de retorno (t) {return (t.textContent || || t.innerText o (t)) indexOf (e)> - 1.}}), lang: OT (function (e) {return X.test (e || "") || st.error ( "sin soporte lang:" + e), e = e.replace (eT, TT) .tolowercase (), función (t) {var n; hacer si (n = d t?. getAttribute ( "xml: lang") || t.getAttribute ( "lang"): t.lang) de retorno n = n.toLowerCase (), n === === e || 0 n.indexOf (e + "- "), mientras que ((t = t.parentNode) && 1 === t.nodeType), y devuelve 1}}), objetivo: la función (t) {var n = e.location && e.location.hash; n de retorno && n.slice (1) === t.id}, raíz: function (e) {return correo === f}, enfoque: función (e) {return correo === p.activeElement && (p.hasFocus || p. hasFocus ()) && !! (e.type || || ~ e.href e.tabIndex)}, habilitado: function (e) {return e.disabled === 1}, personas con discapacidad: la función (e) { directo volver e.disabled === 0}, comprobado: function (e) {var t = e.nodeName.toLowerCase (); return "entrada" === "opción" t && || === e.checked !! t && !! e.selected}, seleccionado: function (e) {return e.parentNode && e.parentNode.selectedIndex, e.selected === 0}, vacío: la función (e) {for (e = e.firstChild; e !; e = e.nextSibling) si (e.nodeName> "@" || 3 || e.nodeType === === 4 e.nodeType) return 1; return 0}, padre: function (e)! {return i.pseudos.empty (e)!}, encabezado: function (e) {return Q.test (e.nodeName)}, de entrada: function (e) {return G.test (e.nodeName)}, botón : function (e) {var t = e.nodeName.toLowerCase (); return "botón" "botón" "entrada" === t && === === e.type || t}, texto: function (e ) {var t; regreso "de entrada" === e.nodeName.toLowerCase () && "texto" === e.type && (null == (t = e.getAttribute ( "tipo")) || t.toLowerCase () === e.type)}, en primer lugar: pt (function () {return [0]}), última: pt (function (e, t) {return [t-1]}), eq: pt ( función (e, t, n) {return [0> n n + t: n?]}), incluso: pt (function (e, t) {var n = 0; para (; t> n, n + = 2 ) e.push (n); declaración electrónica}), impar: pt (function (e, t) {var n = 1; for (; t> n, n + = 2) e.push (n); return e} ), LT: pt (function (e, t, n) {var r = 0> n n + t:? n; for (; - r> = 0;) e.push (r); declaración electrónica}) , GT: pt (function (e, t, n) {var r = 0> n n + t:? n; for (; t> r ++;) e.push (r); return e})}} ; para (n {en la radio: 0, casilla: 0, archivo: 0, contraseña: 0, imagen:!!!!! 0}) i.pseudos [n] = lt (n); for (n en {presentar !!: 0, reset: 0}) i.pseudos [n] = ct (n); función pies (e, t) {var n, r, o, a, S, T, L, C = e [e + ""]; si (c) de retorno t 0:? c.slice (0); s = e, u = [], l = i.preFilter, mientras que (s) {(n || (r = $!. exec (s))) && (r && (s = s.slice (r [0] .length) || s), u.push (o = [])), n =! 1, (r = I.exec (s)) && (n = r.shift (), o.push ({valor n, escriba: r [0] .Colocar (W ",")}), s = s.slice (n.length) ); para) || l [a] && (r = l [a] (r)) || (n = r (a en i.filter) (r = U [a] .exec (s!)!. shift (), o.push ({valor n, escriba: a los partidos: r}), s = s.slice (n.length)), si (n)} ruptura de retorno t s.length:!? s ? st.error (e): e (e, T) .slice (0)} dt (e) {var t = 0, n = e.length, r = ""; for (; n> t; t ++ ) r + = e [t] .value; retorno r} function ht (e, t, n) {var i = t.dir, o = n && "parentNode" === i, a = C ++; vuelva t.first? función (t, n, r) {while (t = t [i]) si (1 === t.nodeType || o) declaración electrónica (t, n, r)}: function (t, n, s) {var u, l, c, p = N + "" + a; si (s) {while (t = t [i]) if ((1 === t.nodeType || o) && e (t, n, s)) return 0} else tiempo (t = t [i]) si (1 === t.nodeType || o) si (c = t [x] || (t [x] = {}), (l = c [i]) && l [0] === p) {if ((U = l [1]) === 0 || u === r) de retorno u === 0} else if (l = c [i] = [p], L [1] = e (t, n, s) || R, L [1] === 0) devuelven 0}} function gt (e) ? {return e.length> 1 función (t, n, r) {var i = e.length;! while (i -) if (! e [i] (t, n, r)) return 1; regreso 0}: e [0]} function tm (e, t, n, r, i) {var o, a = [], s = 0, u = e.length, l = null = t; para (! ; u> s; s ++) (o = e [s]) && (n || n (o, r, i!)) && (a.push (o), l && t.push (s)); volver a} función yt (e, t, n, r, i, o) {return r &&! r [x] && (r = yt (r)), i &&! i [x] && (i = yt (I, O)) , OT (función (o, a, s, u) {var L, C, P, F = [], d = [], h = a.length, g = O || xt (t || "*" , s.nodeType [s]:?! s, []), m = e || o && t g:??? tm (g, f, e, s, u), y = n i || (o e : h || r) []: a:? m; si (n && n (m, y, s, u), r) {l = tm (a, d), r (l, [], s, u) , c = l.length, mientras que (c -) (p = l [c]) && (! y [d [c]] = (m [d [c]] = p))} if (o) { si (i || e) {if (i) {l = [], c = y.length, mientras que (c -) (p = y [c]) && l.push (m [c] = p); i (null, y = [], l, u)} c = y.length; while (c -) (p = y [c]) && (l = i M.call (o, p):? f [c])> - 1 && (o [l] = (a [l] = p!))}} else y = MT (y === un y.splice (h, y.length?): y), i i (nulo, a, Y, U):? H.apply (a, y)})} function vt (e) {var t, n, r, o = e.length, a = i.relative [e [0] .type], s = a || i.relative [ ""], u = a 1: 0, c = ht (function (e) {return correo === t}, s, 0) , p = ht (function (e) {return M.call (t, e)> - 1}!, s, 0), M = [función (e, n, r) {return a && (r || n ! == l) || ((t = n) .nodeType c (e, n, r):? p (e, n, r))}]; for (; o> u; u ++) si (n = i.relative [e [u] .type]) f = [ht (GT (f), n)]; else {si (n = i.filter [e [u] .type] .apply (nulo, e [ U] .matches), n [x]) {for (r = ++ u; r o>; r ++) si (i.relative [e [r] .type]) romper; volver yt (u> 1 && GT (f ), u> 1 && dt (e.slice (0, T-1)). replace (W, "$ 1"), n, r> u && vt (e.slice (u, r)), o> r && vt (e = e .slice (r)), o> r && dt (e))} f.push (n)} gt retorno (f)} function bt (e, t) {var n = 0, o = t.length> 0, una = e.length> 0, s = function (s, u, c, f, d) {var h, g, m, y = [], v = 0, b = "0", x = s && [], w = null = D, T = L, C = s || un i.find.TAG && ( "*", d && u.parentNode || u), k = N + T = null == 1:!? Math.random () || 0,1; para (w && (l = u == p && u, r = n);! null = (h = C [b]); b ++) {if (a h &&) {g = 0; while (m = e [g ++]) si (m (h, u, c)) {f.push (h); descanso}! w && (N = k, r = ++ n)} O && ((h = m && h) && V-- , s && x.push (h))} if (v + = B, O && b == v) {g = 0;! tiempo (m = t [g ++]) m (x, y, u, c), si (s) {if (v> 0), mientras que (b -) x [b] || y [b] || (Y [b] = L.call (f)); y = tm (y)} H.apply ( f, y), w && s && y.length> 0 && v + t.length> 1 && st.uniqueSort (f)} return w && (N = k, l = T), x}; retorno o ot (s):!? s} s = st.compile = function (e, t) {var n, r = [], i = [], o = S [e + ""]; (! o) si {t || (t = ft (e) ), n = t.length, mientras que (n -) o = vt (t [n]), o [x] r.push (o): i.push (o); o = S (e, bt? (i, r))} return o}; xt función (e, t, n) {var r = 0, i = t.length; for (; i> r; r ++) st (e, t [r], n); retorno n} function en peso (e, t, n, r) {var O, a, U, L, C, P = pi (e); if (! r && 1 === p.length) {if ( a = p [0] = P [0] .slice (0), a.length> 2 && "ID" === (U = a [0]). escriba && 9 === t.nodeType &&! d && i.relative [a [1] .type]) {if (t = i.find.ID (u.matches [0] .Colocar (eT, TT), t) [0] ,! t) de retorno n; e = e.slice ( . a.shift () value.length)} o = U.needsContext.test (e) 0:? a.length, mientras que (o -) {if (u = a [o], i.relative [l = u.type]) romper; if ((c = i.find [l]) && (r = c (u.matches [0] .Colocar (eT, TT), V.test (a [0] .type) && t.parentNode || t))) {if (a.splice (O, 1), e = r.length && dt (a) ,! e) devolverá H.apply (n, q.call (r, 0)), n; descanso}}} s de retorno (e, p) (r, t, d, n, V.test (e)), n} = i.pseudos.nth i.pseudos.eq; Tt función () {} i.filters = = Tt.prototype i.pseudos, i.setFilters = nuevo TT, c (), st.attr = b.attr, b.find = st = b.expr st.selectors, b.expr [ " : "] = b.expr.pseudos, b.unique = st.uniqueSort, b.text = st.getText, b.isXMLDoc = st.isXML, b.contains = st.contains} (e); var a = / hasta $ /, st = / ^ (padres ?: | Anterior (: hasta | Todos)?) /, ut = / ^ [^:.. # \ [\,] * $ /, = lt b.expr.match .needsContext, ct = {hijos: 0, contenidos: 0, próxima: 0, Prev:!!!! 0}; b.fn.extend ({encontrar: function (e) {var t, n, r, i = this.length; si ( "cadena" = typeof e!) = r retorno de esto, this.pushStack (b (e) .Filter (function () {for (t = 0; i> t; t ++) si (b. contiene (r [t], este)) return 0}));! a (n = [], t = 0; i> t; t ++) b.find (correo, esta [t], n); n de retorno = this.pushStack (i> 1 b.unique (n):? n), n.selector = (this.selector this.selector + "?": "") + e, n}, tiene: function (e) { var t, n = b (e, este), r = n.length; volver this.filter (function () {for (t = 0; r> t; t ++) if ((b.contains esto, n [t ])) devuelve 0})}, no:!! función (e) {return this.pushStack (ft (este, e, 1))}, filtro: function (e) {return this.pushStack (ft (esto, ! e, 0))}, es:?? función (e) {return !! correo && ( "cadena" == typeof e lt.test (e) b (e, this.context) .index (esto [0] )> = 0: b.filter (e, este) .length> 0: this.filter (e) .length> 0)}, más cercana: function (e, t) {var n, r = 0, i = presente ! .length, o = [], a = lt.test (e) || "cadena" = typeof (, t || this.context e) e b:? 0; for (; i> r; r ++) { n = esta [r], mientras que {si (a a.index (n)> - 1: b.find.matchesSelector (n, e)?) {(n && && n.ownerDocument n == == t && 11 n.nodeType!!) o.push (n); descanso} n = n.parentNode}} return this.pushStack (o.length> 1 b.unique (o): o?)}, índice: function (e) {return e "cuerda? "== typeof e b.inArray (esto [0], b (e)):? b.inArray (e.jquery e [0]:? e, este): esta [0] && esta [0] .parentNode? .. this.first () prevAll () longitud: -1}, añadir: function (e, t) {var n = "cadena" == typeof e b (e, t):? b.makeArray (e && e.nodeType ? [e]: e), r = b.merge (this.get (), n); volver this.pushStack (b.unique (r))}, addBack: function (e) {return this.add (null == e this.prevObject:? this.prevObject.filter (e))}}), b.fn.andSelf = b.fn.addBack; función pt (e, t) {hacer e = e [t]; mientras (! e && 1 == e.nodeType); return e} b.each ({parent: function (e) {var t = e.parentNode; retorno t && 11 == t.nodeType t: nula?}, los padres: la función ( e) {b.dir retorno (e, "parentNode")}, parentsUntil: function (e, t, n) {b.dir retorno (e, "parentNode", n)}, próxima: function (e) {return pt (e, "nextSibling")}, prev: function (e) {pt retorno (e, "previousSibling")}, nextAll: function (e) {b.dir retorno (e, "nextSibling")}, prevAll: función (e) {b.dir retorno (e, "previousSibling")}, nextUntil: function (e, t, n) {b.dir retorno (e, "nextSibling", n)}, prevUntil: function (e, t, n) {b.dir retorno (e, "previousSibling", n)}, hermanos: function (e) {return b.sibling ((e.parentNode || {}). firstChild, e)}, los niños: función (e) {return b.sibling (e.firstChild)}, contenidos: function (e) {return b.nodeName (e, "iframe") || e.contentDocument e.contentWindow.document:? b.merge ( [], e.childNodes)}}, la función (e, t) {b.fn [e] = function (n, r) {var i = b.map (esto, t, n); return at.test ( e) || (r = n), r && "cadena" == typeof r && (i = b.filter (r, i)), i = this.length> 1 &&! ct [e]? b.unique (i) : i, this.length> 1 && st.test (e) && (i = i.reverse ()), this.pushStack (i)}}), b.extend ({filtro: function (e, t, n) { volver n && (e = ": no (" + e + ")"), 1 === t.length b.find.matchesSelector (t [0], e) [t [0]]:?? []: b .find.matches (e, t)}, dir: función (e, n, r) {var i = [], o = e [n], mientras que (o == 9 && && o.nodeType (r t === ! || 1 || == o.nodeType b (o) .is (r))) 1 === o.nodeType && i.push (o), o = O [n]; retorno i}, hermano: función (e, t) {var n = []; para! (; e; e = e.nextSibling) 1 === e.nodeType && e == t && n.push (e); retorno n}}); función pies (e , t, n) {if (t = t || 0, b.isFunction (t)) b.grep retorno (correo, la función (e, r) {var i = !! t.call (e, r, e ); i volver === n}); si (t.nodeType) b.grep retorno (correo, la función (e) {return correo === === t n}); si ( "cadena" == typeof t) {var r = b.grep (e, la función (e) {return 1 === e.nodeType}); si (ut.test (t)) de retorno b.filter (t, r, n!); t = b.filter (t, r)} b.grep retorno (correo, la función (e) {return b.inArray (e, t)> = 0 === n})} dt (e) {var t = ht.split ( "|"), n = e.createDocumentFragment (), si (n.createElement), mientras que (t.length) n.createElement (t.pop ());} n de retorno ht var = "abbr | Artículo | lado | audio | BDI | lona | datos | lista de datos | detalles | figcaption | cifra | pie de página | cabecera | hgroup | marca | metros | nav | salida | progreso | sección | resumen | tiempo | video ", GT = / jQuery \ d + = "(?: nula | \ d +)" / g, mt = RegExp ( "<(?:" + ht + ") [\\ s />]", "i"), yt = / ^ \ s + / , vt = / <(?! área | br | col | embed | h | img | entrada | enlaces | meta | param) (([\ w:] +) [^>] *) \ /> / gi, bt = / <([\ w:] +)? /, xt = / <tbody / i, p = / <| & # \ w +; /, Tt = / <(?: guión | estilo | enlace) / i, Nt = (casilla ?: | radio) / ^ $ / i, Ct = / controladas \ s * (:?. [^ =] | = \ s * .checked) / i, kt = / ^ $ | \ / ( ?: java | ECMA) script / i, Et = / ^ verdadera \ / (*) /, St = / ^ \ s * <(: \ [CDATA \ [| -) | (:.?!? \] \] | -)> \ s * $ / g, A = {opción: [1, "<select múltiple '' múltiples =>", "</ select>"], la leyenda: [1, "<fieldset> "," </ fieldset> "], área: [1," <mapa> "," </ map> "], param: [1," <objeto> "," </ object> "], la culata en T: [1, "<table>", "</ table>"], tr: [2, "<table> <tbody>", "</ tbody> </ table>"], col: [2, "< table> <tbody> </ tbody> <colgroup> "," </ colgroup> </ table> "], td: [3," <table> <tbody> <tr> "," </ tr> </ tbody> </ table> "], _ por defecto:? b.support.htmlSerialize [0," "," "]: [1," X <div> "," </ div> "]}, Jt = dt ( o), Dt = jt.appendChild (o.createElement ( "div")); At.optgroup = At.option, At.tbody = = At.tfoot At.colgroup = = At.caption At.thead, At.th = At.td, b.fn.extend ({text: function (e) {return b.access (esto, la función (e) {return correo === t b.text (este):? this.empty () .Append ((esta [0] && esta [0] .ownerDocument || O) .createTextNode (e))}, nula, e, arguments.length)}, wrapAll: function (e) {if (b.isFunction (e )) volver this.each (función de (t) {b (esto) .wrapAll (e.call (esto, t))}), si (esta [0]) {var t = b (e, esta [0] .ownerDocument) .EQ (0) .clone (0);! esta [0] .parentNode && t.insertBefore (esto [0]), t.map (function () {var e = este, mientras que (== 1 && e.firstChild = e.firstChild.nodeType) e = e.firstChild; retorno e}) append (este)}} devuelva este, wrapInner:. función (e) {return b.isFunction (e) this.each (function (t)? {b (este) .wrapInner (e.call (esto, t))}): this.each (function () {var t = b (este), n = t.contents (); n.length n?. wrapAll (e): t.append (e)})}, envoltura: function (e) {var t = b.isFunction (e); return this.each (function (n) {b (este) .wrapAll (t ? e.call (esto, n): e)})}, desenvuelva: function () {return this.parent () cada uno (function () {b.nodeName (este "cuerpo") || b (esto. ) .replaceWith (this.childNodes)}) final ()}, anexar:. función () {return this.domManip (argumentos, 0, la función (e) {(1 === this.nodeType || == 11! = this.nodeType || 9 === this.nodeType) && this.appendChild (e)})}, anteponga: function () {return this.domManip (argumentos, 0, la función (e) {(1 ===! this.nodeType || 11 || 9 === === this.nodeType this.nodeType) && this.insertBefore (e, this.firstChild)})},antes: function () {return this.domManip (argumentos, 1, función (e) {this.parentNode && this.parentNode.insertBefore (e, this)}!)}, después: function () {return this.domManip (argumentos, ! 1, la función (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, remover: función (e, t) {var n, r = 0; para (; null = (n = esta [r]);!.! r ++) (e || b.filter (e, [n]) de longitud> 0) && (t || 1 || == n.nodeType b.cleanData (Ot (n )), n.parentNode && (t && b.contains (n.ownerDocument, n) && Mt (Ot (n, "script")), n.parentNode.removeChild (n)));} devuelva este, vacío: function () { var e, t = 0; para (; null = (e = esta [t]);! t ++) {1 === e.nodeType && b.cleanData (Ot (e, 1)!), mientras que (e.firstChild) e.removeChild (e.firstChild); e.options && b.nodeName (e, "seleccionar") && (e.options.length = 0)}} devolver este, clon: function (e, t) {return e = null = e = 1:?! e, t = null == t e:? t, this.map (function () {return b.clone (esto, e, t)})}, html: function (e) {return b.access (esto, la función (e) {var n = esta [0] || {}, r = 0, i = this.length; si (e === t) de retorno 1 === n.nodeType? n.innerHTML.replace (gt; ""): t; if ((! "cadena" = typeof e || Tt.test (e) || b.support.htmlSerialize && mt.test (e) || b!!! .support.leadingWhitespace && yt.test (e) || A [(bt.exec (e) || [ "", ""]) [1] .tolowercase ()])) {e = e.replace (vt " <$ 1> </ $ 2> "); try {for (; i> r; r ++) = n esta [r] || {}, 1 === n.nodeType && (b.cleanData (Ot (n, 1! )), n.innerHTML = e); n = 0} catch (o) {}} n && this.empty () append (e)}, nula, e, arguments.length)}, Vuelvaa:. función (e) { var t = b.isFunction (e); t || retorno "cadena" == || typeof e (e = b (e) .no (este) .detach ()), this.domManip ([e] ,! 0, la función (e) {var t = this.nextSibling, n = this.parentNode; n && (b (este) .Remove (), n.insertBefore (e, t))})}, separe: function (e) {return this.remove (e, 0)}, domManip: function (e, n, r) = {e f.apply ([], e); var i, o, a, s, u, l, c = 0, p = this.length, d = esto, h = p-1, g = e [0], m = b.isFunction (g); if (! m || (1> p = || "string ! "= typeof g || b.support.checkClone) && Ct.test (g)) volver this.each (function (i) {var o = d.eq (i); m && (e [0] = g.call (esto, i, n o.html ():? t)), o.domManip (e, n, r)}); si (p && (l = b.buildFragment (correo, esta [0] .ownerDocument ,! 1, este), i = l.firstChild, 1 === l.childNodes.length && (l = i), i)) {for (n = n && b.nodeName (i, "tr"), s = b.map (Ot (l, "script"), HT), a = s.length; p> c;! c ++) o = l, c == h && (! = O b.clone (O, 0, 0), a && b.merge (s, Ot (o "script"))), r.call (n && b.nodeName (esto [c], "tabla") Lt (esto [c], "tbody"):? esta [c ], o, c), si (a) para (u = s [s.length-1] .ownerDocument, b.map (s, qt), c = 0; a> c, c ++) o = s [c ], (o.type || "") && kt.test b._data (O,! "globalEval") && b.contains (u, o) && (o.src b.ajax ({url:? o.src , tipo: "GET", tipoDatos: "guión", asincrónico: 1, global: 1, "lanza": 0}): b.globalEval ((o.text || || o.textContent o.innerHTML || ""))) ") reemplazará (St,."; l = i = null}}} Retorno este); función de Lt (e, t) {return e.getElementsByTagName (t) [0] || e. appendChild (e.ownerDocument.createElement (t))} function Ht (e) {var t = e.getAttributeNode ( "tipo"); return e.type = (t && t.specified) + "/" + e.type, e } function qt (e) {var t = Et.exec (e.type); e.type retorno t = t [1]:? e.removeAttribute ( "tipo"), la función e} Mt (e, t) { var n, r = 0; para (; null = (n = e [r]);! r ++)! b._data (n, "globalEval", t || b._data (t [r], "globalEval" ))} function 't (e, t) {if (1 === t.nodeType && b.hasData (e)) {var n, r, i, o = b._data (e), a = b._data (t , o), s = o.events; si (s) {borrar a.handle, a.events = {}; for (n en s) para el (R = 0, i = s [n] .length; i> r; r ++) b.event.add (t, n, s [n] [r])} a.data && (a.data = b.extend ({}, a.data))}} function pies (e, t) {var n, r, i; si (1 === t.nodeType) {if (n = t.nodeName.toLowerCase () ,! b.support.noCloneEvent && t [b.expando]) {i = b. _data (t); for (r en i.events) b.removeEvent (t, r, i.handle);! t.removeAttribute (b.expando)} "guión" === == n && t.text e.text ? (HT (t) .text = e.text, qt (t)): "objeto" === n (t.parentNode && (t.outerHTML = e.outerHTML), b.support.html5Clone && && e.innerHTML b?! .trim (t.innerHTML) && (t.innerHTML = e.innerHTML)):? "entrada" === n && Nt.test (e.type) (t.defaultChecked = = t.checked e.checked, t.value ! == e.value && (t.value = e.value)):? "opción" === n = t.defaultSelected t.selected = e.defaultSelected :( "entrada" === n || "área de texto" === n) && (t.defaultValue = e.defaultValue)}} b.each ({appendTo: "añadir", Prefijopara: "anteponer", insertBefore: "antes", InsertAfter: "después", replaceAll: "Vuelvaa "}, la función (e, t) {b.fn [e] = function (e) {var n, r = 0, i = [], o = b (e), a = o.length-1; para (; a> = r; r ++) n = r === un presente:? (0) this.clone, b (o [r]) [t] (n), d.apply (i, n.get ()); return this.pushStack (i)}});!? función Ot (e, n) {var r, o, a = 0, s = typeof e.getElementsByTagName == i e.getElementsByTagName (n || !? "*"): typeof e.querySelectorAll == i e.querySelectorAll (n || "*"): t; si (s) para la (s = [], r = e.childNodes || e; nula ! = (o = r [a]); a ++) n || b.nodeName (o, n) s.push (o):? b.merge (s, Ot (o, n)!); n = retorno == t || n && b.nodeName (e, n) b.merge ([e], s):? s} function Bt (e) {Nt.test (e.type) && (e.defaultChecked = e.checked )} b.extend ({clon: function (e, t, n) {var r, i, o, a, s, u = b.contains (e.ownerDocument, e), si (b.support.html5Clone | | b.isXMLDoc (e) || mt.test ( "<" + + e.nodeName ">") o = e.cloneNode (0) :( Dt.innerHTML = e.outerHTML, Dt.removeChild (o!? = Dt.firstChild)),! (b.support.noCloneEvent && b.support.noCloneChecked || 1! == e.nodeType && 11! == || e.nodeType b.isXMLDoc (e))) de (r = Ot (O ), s = Ot (e), a = 0;! null = (i = s [a]); ++ a) r [a] && pies (i, r [a]), si (t) si (n ) para la (s = s || Ot (e), r = r || Ot (O), a = 0; null = (i = s [a]);! a ++) _ t (i, r [a]) ; lo demás 't (e, o); retorno r = Ot (o "script"), r.length> 0 && Mt (! r, u && Ot (e, "script")), r = s = i = null, o} , buildFragment: function (e, t, n, r) {var i, o, a, s, u, L, C, p = e.length, f = dt (t), d = [], h = 0 ; for (; p> h; h ++) si (o = e [h], o || 0 === o) si ( "objeto" === b.type (o)) b.merge (d, o .nodeType [o]: O); else if (wt.test (O)) {s = s || f.appendChild (t.createElement ( "div")), u = (bt.exec (o) |? | [ "", ""]) [1] .tolowercase (), C = A [u] || At._default, s.innerHTML = c [1] + o.replace (vt, "<$ 1> </ $ 2> ") + c [2], i = c [0], mientras que (i -) s = s.lastChild; if (! b.support.leadingWhitespace && yt.test (o) && d.push (t.createTextNode ( yt.exec (o) [0])) ,! b.support.tbody) {o = "mesa"! == u || xt.test (o)? "<table>"! == c [1] || xt.test (o) 0: s: s.firstChild, i = o && o.childNodes.length, mientras que (i -) b.nodeName (L = o.childNodes [i], "tbody") &&?! l.childNodes.length && o.removeChild (l)
} B.merge (d, s.childNodes), s.textContent = ""; mientras que (s.firstChild) s.removeChild (s.firstChild); s = f.lastChild} else d.push (t.createTextNode (O )); s && f.removeChild (s), b.support.appendChecked || b.grep (Ot (d, "entrada"), Bt), h = 0; while (o = d [h ++]) if ((! r || -1 === b.inArray (o, r)) && (a = b.contains (o.ownerDocument, o), s = Ot (f.appendChild (o), "script"), a && Mt ( s), n)) {i = 0; while (o = s [i ++]) kt.test (o.type || "") && n.push (o)} return s = null, f}, CleanData: funciones (e, t) {var n, r, o, a, s = 0, u = b.expando, l = b.cache, p = b.support.deleteExpando, f = b.event.special; for (; null = (n = e [s]);! s ++) if ((t || b.acceptData (n)) && (o = n [U], a = S && l [o])) {if (a.events ) para (r en a.events) f [r] b.event.remove (n, r):? b.removeEvent (n, r, a.handle); l [o] && (eliminar l [o], p borrar n [u]: typeof n.removeAttribute == i n.removeAttribute (u):?!? n [u] = null, c.push (o))}}}); var Pt, Rt, en peso, $ t = / alfa \ ([^)] * \) / i, it = / opacidad \ s * = \ s * ([^)] *) /, ZT = / ^ (arriba | right | Bajo | izquierda) $ /, Xt = / ^ (ninguno |?!. mesa (- c [EA]) +) /, Ut = / ^ margen /, Vt = RegExp ( "^ (" + x + ".) (*) $" "i"), Yt = RegExp ( "^ (" + x + ") (?! px) [az%] + $", "i"), Jt = RegExp ( "^ ([+ -]) = ( "+ x +") "," i "), Gt = {CUERPO:" bloque "}, Qt = {position:" absoluta ", la visibilidad:" oculta ", la pantalla:" bloque "}, Kt = {letterSpacing: 0 , fontWeight: 400}, Zt = [ "Inicio", "derecha", "Abajo", "izquierda"], es = [ "Webkit", "O", "Moz", "MS"]; la función tn (e , t) {if (t en e) de retorno t; var n = t.charAt (0) .toUpperCase () + t.slice (1), r = t, i = en.length, mientras que (yo--) si (t = es [i] + n, t en e) de retorno t; r retorno de la función} nn (e, t) {return e = t || e, "ninguno" === b.css (e " display ") || b.contains (e.ownerDocument, e)} rn función (e, t) {var n, r, i, o = [], a = 0, s = e.length;! a (; s> a; a ++) r = e [a], r.style && (o [a] = b._data (r, "olddisplay"), n = r.style.display, t (o [a] ||? "ninguno"! == n || (r.style.display = ""), "" === r.style.display && nn (r) && (O [a] = b._data (r, "olddisplay", ONU (r.nodeName)))): o [a] || (i = nn (r), (n && "ninguna" == n || i) && b._data (r, "olddisplay", i!!? n: b.css (r, "pantalla")))); para (a = 0; s> a; a ++) r = e [a], r.style && (t && "ninguna" == r.style!. && pantalla "" == r.style.display ||! (r.style.display = t o [a] ||? "": "ninguna"));} declaración electrónica b.fn.extend ({css: función (e, n) {b.access retorno (esto, la función (e, n, r) {var i, o, a = {}, s = 0; si (b.isArray (n)) {for (o = rt (e), i = n.length; i> s; s ++) un [n [s]] = b.css (e, n [s] ,! 1, O);} devuelven un retorno r ==! t b.style (e, n, r):? b.css (e, n)}, e, n, arguments.length> 1)}, espectáculo: function () {rn volver (esto, 0)}! , ocultar: function () {rn retorno (este)}, de palanca: function (e) {var t = "booleano" == typeof electrónico; volver this.each (function () {(t e: nn (esto)? ?) b (este) .show (): b (este) .hide ()})}}), b.extend ({cssHooks: {opacidad: {get: function (e, t) {if (t) { var n = Peso (e, "opacidad"); return "" === n? "1":!!! n}}}}, cssNumber: {columnCount: 0, fillOpacity: 0, fontWeight: 0, lineHeight: 0, de opacidad: 0, huérfanos: 0, viudas: 0, zIndex: 0, zoom: 0}, cssProps: { "flotar":? b.support.cssFloat "cssFloat": "styleFloat"} , estilo: function (e, n, r, i) {if (e && 3 == == 8 e.nodeType && && e.nodeType e.style!) {var o, a, s, u = b.camelCase (n), l = e.style; si (n = b.cssProps [u] || (b.cssProps [u] = tn (L, U)), s = b.cssHooks [n] || b.cssHooks [u], r === t) de retorno s && "llegar" en s && (o = s.get (e, 1, i!)) == t o:!? l [n]; si (a = typeof r, "cadena" === a && (o = Jt.exec (r)) && (r = (O [1] 1) * o [2] + parseFloat (b.css (e, n)), a = "número") ,! (null == r || "número" === a && isNaN (r) || ( "número"! == a || b.cssNumber [u] || (r = + "px"), b.support .clearCloneStyle || ""! == r || 0 == n.indexOf ( "fondo") || (l [n] = "heredar"), s && "set" en s && (r = s.set ( e, r, i)) === t))) {intento l [n] = r} catch (c) {}}}, css: function (e, n, r, i) {var o, a, s, u = b.camelCase (n); return n = b.cssProps [u] || (b.cssProps [u] = tn (e.style, u)), s = b.cssHooks [n] || b.cssHooks [u], s && "llegar" en && s (a = s.get (e, 0, r)), una === t && (a = Peso (e, n, i)), "normal" === a && n en Kt && (a = Kt [n]) "," === r || r (o = parseFloat (a), r === 0 || b.isNumeric (O) O?!? | | 0: a): a}, canje: function (e, t, n, r) {var i, o, a = {}; de (o en T) a [o] = e.style [o], e.style [o] = t [o]; i = n.apply (e, r || []); for (o en t) e.style [o] = a [o]; retorno i}}) , e.getComputedStyle? (Rt = function (t) {return e.getComputedStyle (t, null)}, Wt = function (e, n, r) {var i, o, a, s = r || Rt (e ), u = s s.getPropertyValue? (n) || s [n]: T, L = e.style; s && retorno ( "" == u || b.contains (e.ownerDocument, e) || (u = b.style (e, n)), Yt.test (u) && Ut.test (n) && (i = l.width, o = l.minWidth, a = l.maxWidth, l.minWidth = l .maxWidth = l.width = u, u = s.width, l.width = i, l.minWidth = O, = l.maxWidth a)), u}): o.documentElement.currentStyle && (Rt = función (e ) {return} e.currentStyle, Wt = function (e, n, r) {var i, o, a, s = r || Rt (e), u = s s [n]:? t, l = e .style; return null == u && && l l [n] && (u = l [n]), Yt.test (u) && zt.test (n) && (i = l.left, o = e.runtimeStyle, una! = o && o.left, a && (o.left = e.currentStyle.left), l.left = "fontSize" === n "1 em":? u, u = l.pixelLeft + "px", l.left = i , a && (o.left = a)), "" === u? "auto":? u}); en función de (e, t, n) {var r = Vt.exec (t); r retorno de Matemáticas .max (0, r [1] - (n || 0)) + (r [2] || "px"): t} funcionar un (e, t, n, r, i) {var o = n === (r "frontera": "contenido"?) 4: "anchura" === t 1: 0, a = 0; para (; 4> O; o + = 2) "margen" ===?? n && (a + = b.css (e, n + Zt [o] ,! 0, i)), r? ( "contenido" === n && (a- = b.css (e, "relleno" + Zt [ o] ,! 0, i)), "margen"! == n && (a- = b.css (e, "frontera" + Zt [o] + "Ancho", 0, i))) :( a + = b.css (e, "relleno" + Zt [o] ,! 0, i), "relleno"! == n && (a + = b.css (e, "frontera" + Zt [o] + "Ancho" !, 0, i))); vuelva a} sn función (e, t, n) {var r = 0, i = "ancho" === t e.offsetWidth: e.offsetHeight, o = Rt (!? e), a = b.support.boxSizing && "frontera-box" === b.css (e, "boxSizing", 1, O); if (! 0> = i || == null i) {if ( i = Peso (e, T, o), (0> i || == null i) && (i = e.style [t]), Yt.test (i)) return i; r = a && (b. support.boxSizingReliable || i === e.style [t]), i = parseFloat (i) || 0} return i + un (e, t, n || (una "frontera": "contenido") , r, o) + "px"} función de un (e) {var t = O, n = Gt [e]; retorno n || (n = ln (e, t)!, "ninguno" == n && n | | (Pt = (Pt || b ( "<iframe frameborder =" 0 "width =" 0 "height =" 0 "/>") CSS ( "cssText",. "display: bloque importante")) appendTo. (t.documentElement), t = (Pt [0] .contentWindow || Pt [0] .contentDocument) .document, t.write ( "<! DOCTYPE html> <html> <body>"), t.close ( ), n = ln (e, t), Pt.detach ()), Gt [e] = n), n} la función ln (e, t) {var n = b (t.createElement (e)). appendTo (t.body), r = b.css (n [0], "pantalla"); n.remove retorno (), r} b.each ([ "altura", "ancho"], la función (e, n ) {b.cssHooks [n] = {get:? función (? e, r, i) {return r 0 === e.offsetWidth && Xt.test (b.css (e, "pantalla")) b.swap ( e, Qt, function () {sn retorno (e, n, i)}): sn (e, n, i): t}, establezca: function (e, t, r) {var i = r && Rt (e) ?!; retorno de (e, t, r un (e, n, r, b.support.boxSizing && "frontera-box" === b.css (e, "boxSizing", 1, i), i): 0)}}}), b.support.opacity || (b.cssHooks.opacity = {get: function (e, t) {return It.test ((t && e.currentStyle e.currentStyle.filter:? e.style .Filter) || "") ?. 01 * parseFloat (RegExp $ 1) +. "": t "1": ""}, establezca: function (e, t) {var n = e.style, r = ? e.currentStyle, i = b.isNumeric (t) "alfa (opacidad =" + 100 * t + ")": "", o = r && r.filter || || n.filter ""; n.zoom = 1 , (t> = 1 || "" === t) && "" === b.trim (o.replace ($ t "")) && && n.removeAttribute (n.removeAttribute ( "filtro"), " "=== t || r && r.filter) || (n.filter = $ t.test (o) o.replace ($ t, i):? O +" "+ i)}}), b ( function () {b.support.reliableMarginRight || (b.cssHooks.marginRight = {get: function (e, n) {return n b.swap (e, {display:? "inline-block"}, en peso, [ e "marginRight"]): t}}) ,! b.support.pixelPosition && && b.fn.position b.each ([ "arriba", "izquierda"], la función (e, n) {b.cssHooks [n] = {get:? función (e, r) {return r (r = Peso (e, n), Yt.test (r) b (e) .position () [n] + "px":? r): t }}})}), b.expr && && b.expr.filters (b.expr.filters.hidden = function (e) {return 0> = 0 && e.offsetWidth> = e.offsetHeight ||! b.support.reliableHiddenOffsets && "ninguno "=== (e.style && || e.style.display b.css (e," pantalla "))}, b.expr.filters.visible = function (e) {return! b.expr.filters.hidden ( e)}), b.each ({margin: "", padding: "", en la frontera: "Ancho"}, la función (e, t) {b.cssHooks [e] + t = {ampliar: function (n) {var r = 0, i = {}, o = "cadena" == typeof n n.split ( ""):? [n]; for (; 4> r; r ++) i [e + Zt [r] + t] = O [r] || o [R-2] || O [0]; return i}}, Ut.test (e) || (b.cssHooks [e] + t .set = activado) });? var = cn / 20% / g, pn = / \ [\] $ /, fn = / \ r \ n / g, dn = / ^ (?: presentar botón | | imagen | restablecer | archivo) $ / i, hn = / ^ (entrada ?: | selecto | área de texto | keygen) /i;b.fn.extend ({serializar: function () {return b.param (this.serializeArray ())}, serializeArray: la función () {return this.map (function () {var e = b.prop (esto, "elementos"); return e b.makeArray (e):? esta}). filtrar (function () {var e = this.type; volver this.name && b (este) .es ( ": desactivado") && hn.test (this.nodeName) && dn.test (e) && (this.checked || Nt.test (e!!! ))}) mapa (function (e, t) {var n = b (este) .val (); retorno nula == n nula:.?? b.isArray (n) b.map (n, la función (e ) {return {nombre: t.name, valor: e.replace (fn, "\ r \ n")}}): {name: t.name, valor: n.replace (fn, "\ r \ n" )}}). get ()}}), b.param = function (e, n) {var r, i = [], o = función (e, t) = {t b.isFunction (t)? t (): == null t "": t, i [i.length] = encodeURIComponent (e) + "? =" + encodeURIComponent (t)}; si (n === t && (n = b.ajaxSettings && b.ajaxSettings ! .traditional), b.isArray (e) || e.jquery && b.isPlainObject (e)) b.each (e, function () {O (this.name, this.value)}); más para (r en e) gn (r, [R] e, N, O);. regresar i.join ( "y") sustituir (CN, "+")}; gn función (e, t, n, r) {var ? i; si (b.isArray (t)) b.each (t, la función (t, i) {n || pn.test (e) r (e, i): gn (e + "[" + ( " objeto "== typeof i t:?"! ") +"] ", i, n, r)}); else if (n ||" objeto "== b.type (t)) r (e, t ); los demás por (i en t) gn (e + "[" + i + "]", t [i], n, r)} b.each ( "desenfoque enfoque focusin focusOut de cambio de tamaño de carga de descarga de desplazamiento, haga clic dblclick mousedown mouseup mousemove por encima del ratón mouseout cambio MouseEnter mouseleave seleccionar presentar keydown contextual error de pulsación de tecla keyup ".split (" "), la función (e, t) {b.fn [t] = function (e, n) {return arguments.length> 0? this.on (t, nula, e, n): this.trigger (t)}}), b.fn.hover = function (e, t) {return this.mouseenter (e) .mouseleave (t || e)}; var mn, yn, vn = b.now (), bn = / \ /?, x = / #. * $ /, wn = / ([? &]) _ = [^ &] * /, Tn = / ^ (.? *): [\ t] * ([^ \ r \ n] *) \ r $ / g, Nn = / ^ (sobre ?: | aplicación | app-storage | + - extensión | archivo?. | res | Reproductor): $ / CN = / ^ (GET ?: | HEAD) $ /, = kN / ^ \ / \ //, En = / ^ ([\ w + -.] +:) (? : \ / \ / ([^ \ / #:] *) (? :: (\ d +) |) |) /, Sn = b.fn.load, An = {}, {} = jn, Dn = . "* /" concat ( "*"); try {yn = a.href} catch (Ln) {yn = o.createElement ( "a"), yn.href = "", yn = yn.href} mn = En.exec (yn.toLowerCase ()) || []; la función Hn (e) {función de retorno (t, n) { "cadena" = typeof t && (n = t, t = "*");! var . r, i = 0, o = t.toLowerCase () partido (w) || []; si (b.isFunction (n)), mientras que (r = o [i ++]) "+" === r [0 ] (r = r.slice (1) || "*", (e [r] = e [r] || []) unshift (n).) :( e [r] = e [r]? | . | []) empujar (n)}} function qn (e, n, r, i) {var o = {}, a = e === jn; la función s (u) {var l; O RETURN [u ] = 0, b.each (e [u] || [], la función (e, u) {var c = u (n, r, i);! volver "cadena" = typeof c || a || o [c] un (l = c): t: (n.dataTypes.unshift (c), s (c) ,! 1)}), l} return s (n.dataTypes [0]) |??! ! | o [ "*"] && s ( "*")} función de Mn (e, n) {var r, i, o = b.ajaxSettings.flatOptions || {}; for (i n) n [i] ! == t && ((o [i] e: r || (r = {})) [i] = n [i]?); retorno && r b.extend (0, e, r!), e} b. fn.load = function (e, n, r) {if ( "cadena" = typeof && e Sn!) regresan Sn.apply (esto, argumentos); var i, o, a, s = este, u = e.indexOf ( ""); volver u> = 0 && (i = e.slice (u, e.length), e = e.slice (0, u)), b.isFunction (n) (r = n, n = t? ): n && "objeto" == typeof n && (a = "POST"), s.length> 0 && b.ajax ({url: e, tipo: una, tipoDatos: "html", los datos n}.) hecho (función (e) {o = argumentos, s.html (?.. I B ( "<div>") append (b.parseHTML (e)) encontrar (i): e)}.) completa (función r && (e, t ) {s.each (r, o || [e.responseText, t, e])}), esta}, b.each ([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess "," ajaxSend "], la función (e, t) {b.fn [t] = function (e) {return this.on (t, e)}}), b.each ([" get "," post "], la función (e, n) {b [n] = function (e, r, i, o) {return b.isFunction (r) && (o = O || i, i = r, r = t) , b.ajax ({url: e, tipo n, tipoDatos: o, de datos: r, el éxito: i})}}), b.extend ({activa: 0, LastModified: {}, etag: {}, ajaxSettings: {url: yn, escriba: "GET", isLocal: Nn.test (mn [1]), global: 0, processData: 0, asincrónico: 0, contentType: "/ x-www-formulario de solicitud -urlencoded; charset = UTF-8 ", acepta: {" * ": Dn, texto:" text / plain ", html:" text / html ", xml:" application / xml, text / xml ", JSON:" application / json , text / javascript "}, contenidos: {xml: / xml / html: / html /, JSON: / JSON /}, responseFields: {xml:" responseXML ", texto:" responseText "}, convertidores: {" * texto ": e.String," texto html ": 0", el texto JSON ": b.parseJSON," XML de texto ": b.parseXML}, flatOptions: {url: 0, el contexto: 0}}, ajaxSetup : function (e, t) {? t retorno Mn (Mn (e, b.ajaxSettings), t): Mn (b.ajaxSettings, e)}, ajaxPrefilter: HN (An), ajaxTransport: HN (Jn), Ajax : function (e, n) { "objeto" == typeof e && (n = e, e = t), n = n || {}; var r, i, o, a, s, u, L, C, p = b.ajaxSetup ({}, n), f = p.context || p, d = p.context && (f.nodeType || f.jquery) b (f):? b.event, h = b. diferido (), g = b.Callbacks ( "una vez que la memoria"), m = p.statusCode || {}, {} y =, v = {}, x = 0, T = "cancelado", N = {readyState : 0, getResponseHeader:; (! c) función (e) {var t si (2 === x) {if {c = {}; while (t = Tn.exec (a)) c [t [1] .tolowercase ()] = t [2]} t = c [e.toLowerCase ()]} devolver null == null T:? t}, getAllResponseHeaders: function () {return x 2 === R: null} , setRequestHeader: function (e, t) {var n = e.toLowerCase (); return x || (e = v [n] = v [n] || de correo, y [e] = t), esto}, overrideMimeType: function (e) {return x || (p.mimeType = e), esto}, statuscode: function (e) {var t; si (e) si (2> x) para (t en e) m [ t] = [m [t], e [l]]; lo demás N.always (e [N.status]); retorno este}, abortar: function (e) {var t = e || T; retorno l && l. abortar (t), k (0, t), esto}}; si (h.promise (N) = integro g.add, N.success = N.done, N.error = N.fail, p.url = ((e || || p.url yn) + ""). replace (x n, ""). replace (kn, mn [1] + "//"), p.type = n.method || n.type || || p.method p.type, p.dataTypes = b.trim (p.dataType || "*") toLowerCase. (). emparejamiento (w) || [ ""], == null p.crossDomain && (r = En.exec (p.url.toLowerCase ()), p.crossDomain =! (! r || r [1] === mn [1] && r [2] === mn [2 ] && (r [3] || ( "http:" === r [1] 80: 443)) == (mn [3] || ( "http:"? === mn [1] 80 : 443)))), p.data && && p.processData "cadena" = typeof p.data && (p.data = b.param (p.data, p.traditional)), qn (An, P, N, N) , 2 === x) volver N; u = p.global, u && 0 === b.active ++ && b.event.trigger ( "ajaxStart"), p.type = p.type.toUpperCase (), p. hasContent = Cn.test (p.type), o = p.url, p.hasContent || (p.data && (o = p.url + = (bn.test (o) "&":!? "?") + p.data, eliminar p.data), P.Cache === 1 && (p.url = wn.test (o) o.replace (wn, "$ 1 _ =" + vn ++):? O + (bn. prueba (o) "&":?) + "_ =" + vn ++)), p.ifModified && (b.lastModified [o] && N.setRequestHeader ( "If-Modified-Since", b.lastModified [o "?" ]), b.etag [o] && N.setRequestHeader ( "If-None-Match", b.etag [o])), (p.data && && p.hasContent p.contentType! ==! 1 || n.contentType) && N .setRequestHeader ( "Content-Type", p.contentType), N.setRequestHeader ( "Aceptar", p.dataTypes [0] [&& p.accepts p.dataTypes [0]]? [p.accepts p.dataTypes [0] !] + ( "*" == p.dataTypes [0] "," + Dn +? "; q = 0,01 ":" "): p.accepts [" * "]); for (i en p.headers) N.setRequestHeader (i, p.headers [i]); si (p.beforeSend && (p.beforeSend .call (f, n, p) === === 1 || 2 x)) volver N.abort (); T = "abortar"; for (i in {éxito: 1, error: 1, completa : 1}) N [i] (p [i]), si (l = qn (jn, p, n, N)) {N.readyState = 1, u && d.trigger ( "ajaxSend", [N, p] ), p.async && p.timeout> 0 && (s = setTimeout (function () {N.abort ( "tiempo de espera")}, p.timeout)); try {x = 1, l.send (y, k)} catch (C) {(! (2> x)) si tirar C; k (-1, C)}} k otra cosa (-1, "no hay transporte"); función K (e, n, r, i) {var C, Y, v, w, T, C = n;! == 2 x && (x = 2, s && clearTimeout (s), l = T, a = i || "", N.readyState = e> 0 4? : 0, r && (w = _n (p, n, r)), e> = 200 && 300> e || 304 === e (p.ifModified && (T = N.getResponseHeader ( "última actualización"), T &&? (b.lastModified [o] = T), T = N.getResponseHeader ( "etag"), T && (b.etag [o] = T)), 204 === e? (c = 0, C = " nocontent "):?! 304 === e (c = 0, C =" notmodified ") :( c = Fn (p, w), C = c.state, y = c.data, v = c.error , c =! v)) :( v = C, (e ||! C) && (C = "error", 0> e && (e = 0))), N.status = e, N.statusText = ( n || C) + "", c h.resolveWith (f, [y, C, N]):? h.rejectWith (f, [N, C, v]), N.statusCode (m), m = t, u && d.trigger (c "ajaxSuccess": "ajaxError", [N, P, C y:? v]), g.fireWith (f, [N, C]), u && (d.trigger ( "ajaxComplete "[N, P]), - b.active || b.event.trigger (" ajaxStop ")))}} N retorno, getScript: function (e, n) {return b.get (e, t , n, "script")}, getJSON: function (e, t, n) {b.get retorno (e, t, n, "json")}}); _n función (e, n, r) {var i, o, a, s, u = e.contents, l = e.dataTypes, c = e.responseFields; for (s en c) s en r && (n [c s []] = r [s]); mientras que ( "*" === l [0]) l.shift (), o === t && (o = || e.mimeType n.getResponseHeader ( "Content-Type")); si (o) para ( s en u) si (T [s] && T [s] .test (o)) {l.unshift (s); descanso} if (l [0] en r) a = l [0]; else {for ( s en r) {if (! l [0] || e.converters [s + "" + l [0]]) {a = s; descanso} || i (i = s)} = a i || } devolver un (a == l [0] && l.unshift (a), r [a]!):? función t} Fn (e, t) {var n, r, i, o, a = {}, s = 0, u = e.dataTypes.slice (), l = u [0]; si (e.dataFilter && (t = e.dataFilter (t, e.dataType)), u [1]) para (i en e.converters) un [i.toLowerCase ()] = e.converters [i]; para (; r = u [++ s];) si ( "*" == r) {if ( "*"! == l l &&! == r) {if (i = a [l + "" + r] || a [ "*" + r] ,! i) para (n en a) si (o = n.split ( " "), o [1] === r && (i = a [l +" "+ o [0]] || un [" * "+ o [0]])) {i === 0? i = un [n]: a [n] == 0 && (r = o [0], u.splice (s -, 0, r)); descanso} if (i == 0!) si (i && e! [ "tira"]) t = i (t); lo demás try {t = i (t)} catch (c) {return {estado: "parsererror", error: i c: "Sin la conversión de" + l + "? a "+ r}}} l = r} {retorno estado:" éxito ", los datos: t}} b.ajaxSetup ({acepta: {guión:" text / javascript, application / javascript, application / ECMAScript, application / x -ecmascript "}, contenidos: {secuencia de comandos: / (?: java | ECMA) script /}, convertidores: {" escritura de texto ": function (e) {return b.globalEval (e), e}}}), b .ajaxPrefilter ( "guión", la función (e) {e.cache === t && (e.cache =! 1), e.crossDomain && (e.type = "GET", e.global =! 1)}), b.ajaxTransport ( "guión", la función (e) {if (e.crossDomain) {var n, r = o.head || b ( "cabeza") [0] || o.documentElement; retorno {enviar: función (t, i) {n = o.createElement ( "script"), n.async = 0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n .onreadystatechange = function (e, t) {(t || || n.readyState / cargado |! completa / .test (n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode .removeChild (n), n = null, t || i (200, "éxito"))}, r.insertBefore (n, r.firstChild)}, abortar: function () {n && n.onload (t, 0! ??)}}}}); var = [], Bn = / (=) \ (= & | $) | \ \ /; b.ajaxSetup ({jsonp:?? "callback", jsonpCallback: function ( ) {var e = On.pop () || b.expando + "_" + vn ++; devuelva esta [e] = 0, e!}}), b.ajaxPrefilter ( "JSON jsonp", la función (n, r, i) {var o, a, s, u = n.jsonp == 1 && (Bn.test (n.url) "url":!?! "cadena" == typeof n.data && (n.contentType || "") .indexOf ( "application / x-www-form-urlencoded") && Bn.test (n.data) && "datos"); return u || "JSONP" === n.dataTypes [0] (? ? o = = n.jsonpCallback b.isFunction (n.jsonpCallback) n.jsonpCallback ():? n.jsonpCallback, u n [u] n = [u] .Colocar (Bn, "$ 1" + O): n. ! jsonp == 1 && (n.url + = (bn.test (n.url) "y": "?") + n.jsonp + "=" + o)!, n.converters [ "JSON guión"] = la función () {return s || b.error (o + "no se llama"), s [0]}, n.dataTypes [0] = "json", a = e [o], e [o] = function () {s} = argumentos, i.always (function () {e [o] = a, n [o] && (n.jsonpCallback = r.jsonpCallback, On.push (o)), S && b.isFunction (una ) && a (s [0]), s = a = t}), "script"): t}); var Pn, Rn, Wn = 0, $ n = e.ActiveXObject función && () {var correo, porque (e en Pn) Pn [e] (t, 0)};! en función () {try {return new e.XMLHttpRequest} catch (t) {}} function Zn () {try {return new e.ActiveXObject ( "Microsoft .XMLHTTP ")} catch (t) {}} = b.ajaxSettings.xhr e.ActiveXObject función () {return this.isLocal && En () || Zn ()}:?! En, Rn = b.ajaxSettings.xhr ( ), b.support.cors = Rn !! && "withCredentials" en Rn, Rn = = b.support.ajax !! Rn, Rn && b.ajaxTransport (function (n) {if (! n.crossDomain || b.support. coros) {var r; retorno {enviar: function (i, o) {var a, s, u = n.xhr (), si (n.username u.open (n.type, n.url, n?. asíncrono, n.username, n.password): u.open (n.type, n.url, n.async), n.xhrFields) para la (s en n.xhrFields) u [s] = n.xhrFields [s ]; n.mimeType && && u.overrideMimeType u.overrideMimeType (n.mimeType), n.crossDomain || i [ "X-Requested-Con"] || (i [ "X-Requested-Con"] = "XMLHttpRequest"); trato {for (s en i) u.setRequestHeader (s, i [s])} catch (l) {} u.send (n.hasContent && || n.data nulo), r = function (e, i) {var s , L, C, P; try {si (r && (i || 4 === u.readyState)) si (r = t, a && (u.onreadystatechange = b.noop, $ n && eliminar Pn [a]), i ) == 4 && u.readyState u.abort ();! else {p = {}, s = u.status, l = u.getAllResponseHeaders (), "cadena" == typeof u.responseText && (p.text = u. !? responseText); try {c = u.statusText} catch (f) {c = ""} s || || n.isLocal n.crossDomain 1223 === s && (s = 204): s = p.text ? 200:?? 404}} catch (d) {i || o (-1, d)} p && o (s, c, p, l)}, n.async 4 === u.readyState setTimeout (r) : (a = ++ Wn, n $ && (Pn || (Pn = {}, b (e) .unload ($ n)), Pn [a] = r), u.onreadystatechange = r): r () }, abortar: function () {r && r (t, 0)}}}}); var Xn, Un, Vn = / ^ (?: basculante | mostrar | ocultar) $ /, Yn = RegExp ( "^ (? : ([+ -]) = |) ( "+ x +") ([az] *%) $ "," i "), Jn = / queueHooks $ /, Gn = [NR], Qn = {" * " : [función (e, t) {var n, r, i = this.createTween (e, t), o = Yn.exec (t), a = i.cur (), s = + a || 0, u = 1, L = 20; si (o) {if (n = + o [2], r = o [3] || (b.cssNumber [e] "?": "px"), "px" ! == r && s) = {s b.css (i.elem, e, 0) || n || 1;! hacer u = u || "0.5", s / = u, b.style (i. elem, e, s + r), mientras que (u == (u = i.cur () / a!) && && 1 == u - l)} = r i.unit, i.start = s, i!. final = o [1] + s (O [1] 1) * n:? n} return i}]}; Kn la función () {return setTimeout (function () {Xn} = t), Xn = b.now ()} function Zn (e, t) {b.each (t, la función (t, n) {var r = (Qn [t] || []). concat (Qn [ "*"]), i = 0, o = r.length; for (; o> i; i ++) si (r [i] .call (e, t, n)) return})} er función (e, t, n) {var r, i, o = 0, a = Gn.length, s = b.Deferred () siempre (function () {} u.elem borrar), u = function () {if (i) return 1;.! var t = Xn || Kn (), n = Math.max (0, + l.startTime l.duration-t), r = n / l.duration || 0, o = 1-r, a = 0, u = l .tweens.length; for (; u> a; a ++) l.tweens [a] .run (o); return s.notifyWith (e, [l, o, n]), 1> o && u n: (s? .resolveWith (e, [l]) ,! 1)}, l = s.promise ({elem: e, puntales: b.extend ({}, t), opta: b.extend (0, {specialEasing: {}}, n), originalProperties: t, originalOptions: n, horaInicio: Xn || Kn (), duración: n.duration, preadolescentes: [], createTween: function (t, n) {var r = b.Tween (e, l.opts, t, n, l.opts.specialEasing [t] || l.opts.easing); l.tweens.push retorno (r), r}, se detiene: la función (t) {var n = 0, r = t l.tweens.length:? 0; si (i) devolver este; for (i = 0; r> n; n ++!) l.tweens [n] .run (1); t retorno? s.resolveWith (e, L, T []): s.rejectWith (e, L, T []), esta}}), c = l.props; for (tr (c, l.opts.specialEasing); a> O; O ++) si (r = Gn [o] .call (L, e, C, l.opts)) r retorno; volver Zn (l, c), b.isFunction (l.opts.start) && l .opts.start.call (e, l), b.fx.timer (b.extend (u, {elem: e, anim: l, cola: l.opts.queue})), l.progress (p. opts.progress) .done (l.opts.done, l.opts.complete) .fail (l.opts.fail) .always (l.opts.always)} La función tr (e, t) {var n, r , i, o, a; for (i en e) si (r = b.camelCase (i), o = t [r], n = e [i], b.isArray (n) && (O = n [ 1], n = e [i] = n [0]), i! == r && (e [r] = n, eliminar e [i]), a = b.cssHooks [r], a && "ampliar" a a) {n = a.expand (n), eliminar e [r]; for (i n) i en e || (e [i] = n [i], t [i] = O) t} else [r] = O} = b.Animation b.extend (er, {tweener:? función (e, t) {b.isFunction (e) (t = e, e = [ "*"]): e = e .split ( ""); var n, r = 0, i = e.length; for (; i> r; r ++) n = e [r], Qn [n] = Qn [n] || [], qn [n] .unshift (t)}, prefiltro: function (e, t) {t Gn.unshift (e):? Gn.push (e)}}); función nr (e, t, n) {var r, i, o, a, s, u, L, C, P, F = este, d = e.style, h = {}, g = [], m = nn e.nodeType && (e); n.queue || (c = b._queueHooks (e, "FX"), == null && c.unqueued (c.unqueued = 0, p = c.empty.fire, c.empty.fire = function () {c.unqueued || p ()}), c.unqueued ++, f.always (function () {f.always (function () {c.unqueued -., b.queue (e, "FX") de longitud || c. empty.fire ()})})), 1 === e.nodeType && ( "altura" en t || "ancho" en t) && (n.overflow = [d.overflow, d.overflowX, d.overflowY ], "en línea" === b.css (e, "pantalla") && "ninguna" === b.css (e, "flotar") && (b.support.inlineBlockNeedsLayout && "en línea"! == ONU ( e.nodeName) ZOOM D = 1:? d.display = "inline-block")), n.overflow && (d.overflow = f.always "ocultos", b.support.shrinkWrapBlocks || (function () { d.overflow = n.overflow [0], d.overflowX = n.overflow [1], d.overflowY = n.overflow [2]})); for (i en t) si (a = t [i] , Vn.exec (a)) {if (borrar t [i], u = u || "cambiar" === a, a === (m "ocultar": "mostrar")) continúan; g. push (i)} if (o = g.length) {s = b._data (e, "fxshow") || b._data (e, "fxshow", {}), "escondido" en s && (m = s.hidden), u && (! s.hidden = m), m b (e) .show) (?: f.done (function () {b (e) .hide ()}), f.done (función () {var t; b._removeData (e, "fxshow"); for (t en h) b.style (e, t, h [t])}); for (i = 0; o> i; i ++ ) r = g [i], l = f.createTween (r, m s [r]: 0), h [r] = s [r] || b.style (e, r), r en s |? | (s [r] = l.start, m && (l.end = l.start, l.start = "ancho" === r || "altura" === r 1: 0)?)}} function rr (e, t, n, r, i) {return new rr.prototype.init (e, t, n, r, i)} b.Tween = RR, rr.prototype = {constructor: rr, init: función (e, t, n, r, i, o) {this.elem = e, this.prop = n, i = this.easing || "swing", this.options = t, this.start = this.now = this.cur (), this.end = r, this.unit = O || (b.cssNumber [n] "?": "px")}, cur: function () {var e = rr.propHooks [ this.prop]; regresar e && e.get e.get (este): rr.propHooks._default.get (este)}, ejecute:? función (e) {var t, n = rr.propHooks [this.prop]; volver this.pos = t = this.options.duration b.easing [this.easing] (e, this.options.duration * e, 0,1, this.options.duration):? e, this.now = ( this.end-this.start) * t + this.start, this.options.step && this.options.step.call (this.elem, this.now, este), n && n.set n.set (este):? rr .propHooks._default.set (este), esto}}, rr.prototype.init.prototype = rr.prototype, rr.propHooks = {_ defecto: {get: function (e) {var t; == retorno nula e. elem [e.prop] && || e.elem.style nula! = e.elem.style [e.prop]? (t = b.css (e.elem, e.prop, ""), t && "auto"! == t t:? 0): e.elem [e.prop]}, establezca: function (e) {b.fx.step [e.prop] b.fx.step [e.prop] (e)? : e.elem.style && (null = e.elem.style [b.cssProps [e.prop]] || [b.cssHooks e.prop]!) b.style (e.elem, e.prop, e? .now + e.unit): e.elem [e.prop] = e.now}}}, rr.propHooks.scrollTop = = {rr.propHooks.scrollLeft conjunto: function (e) {e.elem.nodeType && e. elem.parentNode && (e.elem [e.prop] = e.now)}}, b.each ([ "cambiar", "espectáculo", "ocultar"], la función (e, t) {var n = b. fn [t]; b.fn [t] = function (e, r, i) {return nula e || == "booleano" == typeof e n.apply (este, argumentos): this.animate (IR? (t, 0), e, r, i)}}), b.fn.extend ({fadeTo: function (e, t, n, r) {return this.filter (nn) .css ( "opacidad" .., 0) .show () end () animar ({opacidad: t}, e, n, r)}, animado: function (e, t, n, r) {var i = b.isEmptyObject (e) , o = b.speed (t, n, r), a = function () {var t = er (esto, b.extend ({}, e), o); a.finish = function () {t. stop (0)}, (i || b._data (esto, "terminar")) && t.stop (0)}; retorno a.finish = a, i || o.queue === 1!? this.each (a): this.queue (o.queue, a)}, parada: function (e, n, r) {var i = function (e) {var t = e.stop; eliminar e.stop, t (r)}; return "cadena" = typeof e && (r = n, n = e, e = t), n && e == 1 && this.queue (e || "FX", []), esto!!!. cada uno (function () {var t = 0, n = null = e && e + "queueHooks", o = b.timers, a = b._data (este);! if (n) un [n] && un [n]. detener && I (a [n]); los demás por (n en a) un [n] && un [n] .Stop && Jn.test (n) && I (a [n]); for (n = o.length; n-; ) o [n] .ELEM! == || este nula! = e && o [n] .queue! == e || (o [n] .anim.stop (r), t =! 1, o.splice ( n, 1)); (t || r) && b.dequeue (esto, e)})}, acabado:!!! función (e) {return correo == 1 && (e = e || "FX"), this.each (function () {var t, n = b._data (este), r = n [e + "cola"], i = n [e + "queueHooks"], o = b.timers, a = r? r.length: 0; para (n.finish = 0, b.queue (este, e, []), i && && i.cur i.cur.finish && i.cur.finish.call (este), t = o.length; t -;) o .ELEM [t] === esta && o [t] .queue === e && (! o [t] .anim.stop (0), o.splice (t, 1)); para ( t = 0; a> t; t .finish.call ++) r [t] && r [t] .finish && r [t] (este); eliminar n.finish})}}); la función del IR (e, t) {var n, r = {height: e}, i = 0; para (t = t 1: 0; 4> i; i + = 2-t) n = Zt [i], r [ "margen" + n] = r [ "relleno" + n] = e; retorno t && (r.opacity = r.width = e), r} b.each ({slideDown: IR ( "show"), slideUp: IR ( "ocultar"), slideToggle: IR ( "cambiar"), fadeIn: {opacidad: "espectáculo"}, fadeOut: {opacidad: "ocultar"}, fadeToggle: {opacidad: "cambiar"}}, la función (e, t) {b.fn [e] = function (e, n, r) {return this.animate (t, e, n, r)}}), b.speed = function (e, t, n) {var r = e && "objeto" == typeof e b.extend ({}, e):? {completa: n || n || && t b.isFunction (e) && e, duración:! e, aliviando: n && || t t && b.isFunction (t) && t}; r.duration retorno = 0 b.fx.off:? "número" == typeof r.duration r.duration: r.duration en b.fx.speeds b.fx.speeds [r.duration]? : b.fx.speeds._default, (! == nula r.queue || r.queue === 0) && (r.queue = "FX"), r.old = r.complete, r.complete = function () {b.isFunction (r.old) && r.old.call (este), r.queue && b.dequeue (esto, r.queue)}, r}, {b.easing = lineal: function (e) { volver e}, columpio: function (e) {return.5-Math.cos (e * Math.PI) / 2}}, b.timers = [], b.fx = rr.prototype.init, b.fx .tick = function () {var e, n = b.timers, r = 0; para (Xn = b.now (); n.length> r; r ++) e = n [r], e () || n [r] == e || n.splice (r -, 1);! n.length || b.fx.stop (), Xn = t}, b.fx.timer = function (e) { e () && b.
